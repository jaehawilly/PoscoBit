!SESSION 2022-10-28 08:55:55.048 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

This is a continuation of log file C:\Users\BIT\eclipse-workspace\.metadata\.bak_0.log
Created Time: 2022-10-28 14:18:15.193

!ENTRY org.eclipse.jdt.ui 4 2 2022-10-28 14:18:15.194
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-10-28 14:18:15.196
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-28 14:18:15.288
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package Pack01;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.Random;
import java.util.Scanner;

// ex)
//public class Hello {
//	public static void main(String[] args) {
//		
//	}
//}


//ex65)
public class Hello {
	static String hexaToBinary(int n) {
		String result = Integer.toBinaryString(n);
		
		while(result.length() < 32) {
			result = "0" + result;
		}
		StringBuffer result1 = new StringBuffer(result);
		for (int i = 0; i < 7; i++) {
			result1.insert((7-i)*4, " ");
		}
		return result1.toString();
	}
	
	public static void main(String[] args) {
		// ARGB
		int num = 0x3b12cd59;
		//        0x3b12cd59; A
		//      & 0x00ff0000; M
		//        0x00120000; R
		//  >> 16 0x00000012;
		System.out.println(hexaToBinary(num));
		System.out.println(hexaToBinary(0x00ff0000));
		System.out.println(hexaToBinary(num & 0x00ff0000));
		System.out.println(hexaToBinary((num & 0x00ff0000) >> 16));
		int Red = (num & 0x00ff0000) >> 16;
		System.out.println(Red);
		
		int Green = (num & 0x0000ff00) >> 8;
		System.out.println(Green);
		
		int Blue = (num & 0x000000ff);
		System.out.println(Blue);
		
		(Red << 16) || (Green << 8) || Blue
	}
}



/*
//ex64) 비트 연산
public class Hello {
	static String hexaToBinary(int n) {
		String result = Integer.toBinaryString(n); //111011000100101100110101011001
		//System.out.println("1 : " + result.length());
		
		while(result.length() < 32) {
			result = "0" + result;
		}
		//System.out.println("2 : " + result);
		
		StringBuffer result1 = new StringBuffer(result); // StringBuffer는 갱신을 할수있다
		//System.out.println("3 : " + result1);
		
		for (int i = 0; i < 7; i++) {
			result1.insert((7-i)*4, " ");
		}
		//System.out.println("4 : " + result1); //0011 1011 0001 0010 1100 1101 0101 1001
		return result1.toString(); //StringBuffer를 String으로 변환해준다(return값이 String이므로)
	}
	
	public static void main(String[] args) {
		// 앞에 0x가 붙으면 뒤에는 16진수가 된다 / 0만 붙으면 뒤에는 8진수가 된다
		// 진법 : 2진법, 10진법, 16진법(개인적으로 익히기)
		// 16진법 : 0 1 2 3 4 5 6 7 8 9 A  B  C  D  E  F
		//                           10 11 12 13 14 15
		int num = 0x3b12cd59; //16진수를 2진수로 바꿔보자!
		// 이진수 : 11 1011 0001 0010 1100 1101 0101 1001
		// 끝에서부터 4자리씩 끊고 앞에 공백에 0채워넣기
		// 0011 1011 0001 0010 1100 1101 0101 1001
		String result = Integer.toBinaryString(num); //111011000100101100110101011001
		System.out.println(result);
		
		//직접 함수 만들어서 네자리씩 끊기
		System.out.println(hexaToBinary(num));
	}
}
*/


/*
//ex63-2) 제네릭 문법
// class 개수를 줄이는 건 아님(class는 사용할때마다 내부적으로 생성된다) - 보이는 코드길이만 줄어듦
class Tiger<T>{
	private T data;
	
	public T getData() {
		return data;
	}
	public void setData(T data) {
		this.data=data;
	}
}
public class Hello {
	public static void main(String[] args) {
		// Tiger<Integer> t = new Tiger<Integer>();
		Tiger<Integer> t1 = new Tiger<>();
		t1.setData(100);
		System.out.println(t1.getData());
		
		
		Tiger<String> t2 = new Tiger<>();
		t2.setData("호랑이");
		System.out.println(t2.getData());
		
		
		Tiger<Float> t3 = new Tiger<>();
		t3.setData(3.14f);
		System.out.println(t3.getData());
		
		LinkedList<String> mm = new LinkedList<>();
		
	}
}
*/


/*
//ex63-1) 제네릭이 필요한 이유를 설명한 코드
class Tiger{
	private int data;
	
	public int getData() {
		return data;
	}
	public void setData(int data) {
		this.data=data;
	}
}
class Lion{
	private String data;
	
	public String getData() {
		return data;
	}
	public void setData(String data) {
		this.data=data;
	}
}
public class Hello {
	public static void main(String[] args) {
		Tiger t = new Tiger();
		t.setData(100);
		System.out.println(t.getData());
		
		Lion l = new Lion();
		l.setData("호랑이");
		System.out.println(l.getData());
	}
}
*/



/*
//ex62) annotation(@)
class A{
	void showMeTheMoney() {
		
	}
}

class B extends A{
	// @Override를 붙이는 이유(annotation)
	// : 이렇게 오타를 발생시키고 override를 하면 오류발생을 알려줌
//	@Override
//	void ShowMeTheMoney() {
//		System.out.println(2);
//	}
}

interface C{
	void f1();
}
class D implements C{
	// 코드 자동 완성을 이용하였다.(ctrl+space)
	@Override
	public void f1() {
		// TODO Auto-generated method stub
		
	}
}

public class Hello {
	public static void main(String[] args) {
		A a = new B();
		a.showMeTheMoney();
	}
}
*/


/*
//ex61) Collection
// CRUD(Create, Read, Update, Delete)에 맞게 알맞은 자료구조를 선택해서 사용해야함
// List(순서가 있음) - LinkedList, Stack, Vector, ArrayList
// Set(중복X) - HashSet, SortedSet-TreeSet
// Map(key:value) - Hashtable, HashMap, SortedMap-TreeMap

// LinkedList - 평균적으로 좋은 것, 추가, 삭제에 좋음, but 검색에 취약함
// 나머지는 각자 시간날때 해볼것!
// Queue Interface는 PriorityQueue, Deque, ArrayDeque

// Collection 중 LinkedList의 예시
public class Hello {
	public static void main(String[] args) {
		// <저장할 데이터 타입>
		// 반드시 클래스 타입만 가능하다.(LinkedList<int> 이런건 안됨)
		// LinkedList<Integer> mm = new LinkedList<Integer>();
		LinkedList<Integer> mm = new LinkedList<>();
		System.out.println(mm.size());
		
		// (Create)RUD
		mm.add(100);
		for (int i = 0; i < 10; i++) {
			mm.add(i*10+i);
		}
		System.out.println(mm.size() + "개 있다");
		
		// C(Read)UD
		// 방법1 : 활용성이 없다.(당장은 편하지만)
		System.out.println(mm);
		
		// 방법2 : 
		for (int i = 0; i < mm.size(); i++) {
			System.out.print(mm.get(i) + " ");
		}System.out.println();
		
		// 방법 : forEach :
		// i, data, x, value, item
		for (Integer value : mm) {
			System.out.print(value + " ");
		}System.out.println();
		
		int[] ar = {1, 2, 3};
		for (int value : ar) {
			System.out.print(value + " ");
		}System.out.println();
		
		System.out.println(mm.get(5));
		
		// CR(Update)D
		mm.set(5, 2022);
		System.out.println(mm);
		
		// CRU(Delete)
		mm.remove(4);
		System.out.println(mm);
		
		// C : create, insert, add
		// R : read, select, get
		// U : update, set
		// D : delete, remove, erase, clear
	}
}
*/
//2022.10.28


/*
//ex60) String
public class Hello {
	public static void main(String[] args) {
		String s = "무궁화꽃이피었습니다";
		
		// 1) 문자열 길이
		System.out.println(s.length()); //10
		
		// 2) 해당 인덱스의 문자
		System.out.println(s.charAt(3)); //꽃
		
		// 3) 해당 문자열의 시작인덱스(정확하게 일치하는 문자열이 포함되어있을때만)
		System.out.println(s.indexOf("궁화")); //1
		System.out.println(s.indexOf("나무")); //-1(포함X)
		if(s.indexOf("나무")==-1) {
			System.out.println("not found");
		}else {
			System.out.println("find");
		}
		
		// 4) 해당 문자열1을 해당 문자열2로 대체해서 출력함(단, 원본은 안바뀜)
		System.out.println(s.replace("꽃이", "나무가")); //무궁화나무가피었습니다
		System.out.println(s); //무궁화꽃이피었습니다
		String newString = s.replace("꽃이", "식물이");
		System.out.println(newString); //무궁화식물이피었습니다
		
		// 5) 해당 인덱스부터 끝까지 자른다(끝범위도 지정 가능)
		System.out.println(s.substring(3)); //꽃이피었습니다
		System.out.println(s.substring(3, 5)); //꽃이
		//(a, b) >> a부터 b-1까지
		
		
		// 그 외 String 클래스 메소드(실습)
		// 문자열에 이어붙이기(원본이 바뀌진 않음)
		System.out.println(s.concat("안녕")); //무궁화꽃이피었습니다안녕
		System.out.println(s); //무궁화꽃이피었습니다
		
		// 문자열에 해당 문자열이 포함되어있는지 true/false로 출력
		System.out.println(s.contains("궁")); //true
		System.out.println(s.contains("안")); //false
		
		// 문자열이 해당 문자열로 끝나는지 true/false로 출력
		System.out.println(s.endsWith("다")); //true
		System.out.println(s.endsWith(".")); //false
		
		// 문자열이 해당 문자열과 완전히 같은지 true/false로 출력
		System.out.println(s.equals("무궁화꽃이피었습니다")); //true
		System.out.println(s.equals("무궁화")); //false
		
		// 해당 문자열이 빈 문자열인지 true/false로 출력
		System.out.println(s.isEmpty()); //false
		System.out.println("".isEmpty()); //true
		
		// 문자열을 해당 문자열로 완전히 대체함(원본은 바뀌지 않음)
		System.out.println(s.replaceAll(s, "안녕")); //안녕
		System.out.println(s); //무궁화꽃이피었습니다
		
		// 문자열을 해당 문자열을 기준으로 나눠준다(원본은 바뀌지 않음)
		System.out.println(s.split("이")[0]); //무궁화꽃
		System.out.println(s.split("이")[1]); //피었습니다
		System.out.println(s); //무궁화꽃이피었습니다
		
		// 문자열을 소문자, 대문자로 바꿔준다(원본은 바뀌지 않음)
		String str = "aBcDefgH";
		System.out.println(str.toLowerCase()); //abcdefgh
		System.out.println(str.toUpperCase()); //ABCDEFGH
		System.out.println(str); //aBcDefgH
		
		// 문자열의 왼쪽, 오른쪽 공백을 제거해준다(가운데 공백들은 제거X)
		String str2 = " a b  c   d ";
		System.out.println(str2.trim()); //a b  c   d
	}
}
*/

/*
//ex59) Scanner(입력)
public class Hello {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.println("숫자를 입력하세요");
		int num = sc.nextInt();
		System.out.println("입력된 숫자는 : " + num + "입니다.");
	}
}
*/


/*
//ex58) Thread.sleep()
public class Hello {
	public static void main(String[] args) {
		System.out.println(1);
		
		for (int i = 0; i < 5; i++) {
			
			// 특정 조건 만족한 이후에 함수실행을 끝내는 이러한 함수를
			// 블로킹함수.
			try {Thread.sleep(3000);} catch (InterruptedException e) {}
			System.out.println(i*10);
		}
		
		System.out.println(2);
	}
}
*/


/*
//ex57)
class Tiger{
	void f1() {
		System.out.println(1);
		
		try {
			throw new Exception();			
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	// 이 함수를 호출한 게 Exception을 catch함
	void f2() throws Exception{
		System.out.println(2);
		throw new Exception();
	}
}
public class Hello {
	public static void main(String[] args) {
		Tiger t = new Tiger();
		t.f1();
		
		// Unhandled exception type Exception
		try {
			t.f2();			
		} catch (Exception e) {
			e.printStackTrace();
		}
		System.out.println("end");
	}
}
*/


/*
//ex56) 예외처리(exception)
public class Hello {
	public static void main(String[] args) {
		
		// 1. Arithmetic Exception
		try {
			System.out.println(4/0);
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		// 2. ArrayIndexOutOfBoundsException
		int[] ar = new int[3];
		try {
			ar[3] = 10;			
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		// 3. NullPointerException
		String str = null;
		try {
			System.out.println(str.length());			
		} catch (Exception e) {
			e.printStackTrace();
		}

		System.out.println("무궁화꽃이피었습니다.");
	}
}
*/


/*
//ex55) 삼항연산
public class Hello {
	public static void main(String[] args) {
		
		// ex1
		int num1;
		if(true) {
			num1 = 10;
		}else {
			num1 = 20;
		}
		
		num1 = true ? 10 : 20;
		
		// ex2
		if (true) {
			System.out.println("호랑이");
		}else {
			System.out.println("코끼리");
		}
		
		System.out.println(true ? "호랑이" : "코끼리");
		
		Tiger t = new Tiger();
		t.f1(3, 4);
		
		
		// 우박수 문제(삼항연산자로 표현)
		int num=1234567;
		while(true) {
			System.out.println(num);
			num = (num%2==0) ? num/2 : num*3+1;
			
			if(num==1) {
				System.out.println(num);
				break;
			}
		}

	}
}
class Tiger{
	int f1(int a, int b) {
//		if(a > b) {
//			return 1000;
//		}else {
//			return 2000;
//		}
		return a > b ? 1000 : 2000;
	}
}
*/


/*
//ex54)
interface Animal{
	abstract void cry();
}
class Dog implements Animal{
	public void cry() {System.out.println("멍멍");}
}
class Cat implements Animal{
	public void cry() {System.out.println("야옹");}
}
public class Hello {
	public static void main(String[] args) {
		Animal t = new Dog();
		t.cry();
	}
}
*/

/*
//ex53)
class Animal{
	void cry() {System.out.println("잉잉");}
}
class Dog extends Animal{
	void cry() {System.out.println("멍멍");}
}
class Cat extends Animal{
	void cry() {System.out.println("야옹");}
}
class Snake extends Animal{
	// cry() 구현없으면 부모를 따른다.
}
public class Hello {
	public static void main(String[] args) {
//		Dog t1 = new Dog();
//		Cat t2 = new Cat();
//		Snake t3 = new Snake();
//		
//		for (int i = 0; i < 5; i++) {
//			switch (new Random().nextInt(3)) {
//			case 0: t1.cry(); break;
//			case 1: t2.cry(); break;
//			case 2: t3.cry(); break;
//			default: break;
//			}			
//		}
//		int a, b, c;
//		int[] ar = new int[3];
//		Animal[] ani = new Animal[3];
//		ani[0] = new Dog();
//		ani[1] = new Cat();
//		ani[2] = new Snake();
		
		
// 		위의 코드와 동일한 코드이다.(이렇게 줄일수있다.)
		Animal[] ani = new Animal[] { new Dog(), new Cat(), new Snake()};
		for (int i = 0; i < 5; i++) {
			ani[new Random().nextInt(3)].cry();			
		}
	}
}
*/


/*
//ex52)업캐스팅을 하는 이유
class Animal{
	void cry() {
		System.out.println("잉잉");
	}
}
class Dog extends Animal{
	void cry() {
		System.out.println("멍멍");
	}
}
class Cat extends Animal{
	void cry() {
		System.out.println("야옹");
	}
}
class Snake extends Animal{
	// cry() 구현없으면 부모를 따른다.
}
class Zoo{
	// 1. upcasting을 하게 되면 이렇게 하나만으로 모든 cry() 동작을 할 수 있다
	// Animal ani = new Dog(), new Cat(), new Snake()
	void sound(Animal ani) {
		ani.cry();
	}
	
	
	// 2. upcasting을 안하게 되면 이렇게 동물이 추가될때마다 cry()를 추가해야함
	void sound(Dog dog) {
		dog.cry();
	}
	void sound(Cat cat) {
		cat.cry();
	}
	void sound(Snake snake) {
		snake.cry();
	}
}
public class Hello {
	public static void main(String[] args) {
		Animal t1 = new Dog();
		Animal t2 = new Cat();
		Animal t3 = new Snake();
		t1.cry();
		t2.cry();
		t3.cry();
		System.out.println("--------------------");
		
		Dog t4 = new Dog();
		Cat t5 = new Cat();
		Snake t6 = new Snake();
		t4.cry();
		t5.cry();
		t6.cry();
		System.out.println("--------------------");
		
		Zoo zoo = new Zoo();
		zoo.sound(new Dog());
		zoo.sound(new Cat());
		zoo.sound(new Snake());
	}
}
*/


/*
//ex51) 다형성(업캐스팅)
// 클래스의 결과나 인터페이스나 동일하다.
class A{
	void f1() {
		System.out.println(1);
	}
	void f2() {
		System.out.println(2);
	}
	void f3() {
		System.out.println("f3 call");
		f4(); // 자식꺼에도 있으면 부모꺼가 아닌 자식꺼를 실행시킨다.
	}
	void f4() {
		System.out.println("부모 f4");
	}
}
class B extends A{
	void f2() {
		System.out.println(3);
	}
	void f4() {
		System.out.println("자식 f4");
	}
}
public class Hello {
	public static void main(String[] args) {
		// 부 = 자
		A t = new B();
		t.f1();
		t.f2();
		t.f3();
	}
}
*/



/*
//ex50) 다형성
class A{
	void f1() {}
}

class B extends A{
	void f2() {}
}

public class Hello {
	public static void main(String[] args) {
		// 좌변은 문법 구사 / 우변은 할당메모리를 의미함
		// 상속과는 무관하다.
		A t1 = new A();
		t1.f1();
		
		
		// up casting(업캐스팅)
		A t2 = new B(); //문법적으로는 A만, 할당된 메모리는 둘다(가능)
		t2.f1();
		
		
		// 자바에서 지원하지 않는다.(다운캐스팅)
//		B t3 = new A(); // 문법적으로는 A,B 둘다, 할당된메모리는 A만(오류)
		
		
		// 자식것을 보고 없으면 부모것을 살펴본다.
		B t4 = new B();
		t4.f1();
		t4.f2();
	}
}
*/

/*
//ex49-2)
class A {void f1() {System.out.println(1);}}
interface B{void f2();}
interface C{void f3();}
class D extends A implements B, C{
	public void f2() {System.out.println(2);}
	public void f3() {System.out.println(3);}
}
public class Hello {
	public static void main(String[] args) {
		D t = new D();
		t.f1();
		t.f2();
		t.f3();
		
		StringBuffer sb;
	}
}
*/


/*
//ex49-1)
interface A{
	void f1();
}
interface B{
	void f2();
}
class C implements A, B{
	public void f1() {System.out.println(1);}
	public void f2() {System.out.println(2);}
}
public class Hello {
	public static void main(String[] args) {
		C t = new C();
		t.f1();
		t.f2();
	}
}
*/


/*
//ex48)
// abstract : 클래스이기 때문에 다중상속을 할 수 없다.
// interface 동일한 조건일때는 interface를 선택(다중상속을 할 수 있다.)
interface Tiger{
	abstract void f1();
	void f2();
}
class Lion implements Tiger{
	// interface에 있는 것을 구현한 함수는 반드시 public 이어야 한다.
	public void f1() {	System.out.println(1);}
	public void f2() {	System.out.println(2);}
}
public class Hello {
	public static void main(String[] args) {
		Lion t = new Lion();
		t.f1();
		t.f2();
	}
}
*/

/*
//ex47)
abstract class 대장장이{
	void 칼() {
		System.out.println("칼 만듦");
	}
	abstract void 방패();
}
class 병사1 extends 대장장이{
	void 방패() {
		System.out.println("드래곤이빨 방패 구해서 사용함");
	}
}
class 병사2 extends 대장장이{
	void 방패() {
		System.out.println("나무 방패 구해서 사용함");
	}
}
public class Hello {
	public static void main(String[] args) {
		병사1 t1 = new 병사1();
		t1.칼();
		t1.방패();
		병사2 t2 = new 병사2();
		t2.칼();
		t2.방패();
	}
}
*/

/*
//ex46)
abstract class Tiger{
	// 추상 함수이다.
	// 추상 함수를 1개라도 가지는 클래스는 반드시 추상 클래스이어야 한다.
	abstract void f1(); // 미완성코드(abstract : 추상)
	
	// 완성된 코드
	void f2() {
		System.out.println(1);
	}
}

// 상속받은 자식은 반드시 부모의 미완성코드를 완성해야 한다.
// 오버라이드(override) 문법을 이용해서
class Lion extends Tiger{
	void f1() {
		System.out.println(2);
	}
}

public class Hello {
	public static void main(String[] args) {
		// 추상 클래스는 객체 생성을 할 수 없다.
		// Tiger t = new Tiger();(X)
		Lion t = new Lion();
		t.f1();
		t.f2();
	}
}
*/

/*
//ex45)
// 자식은 부모이다.
// 사자는 호랑이이다.(X)
// 사자는 동물이다.(O) (is a)
class Tiger{}
class Animal{}
class Lion extends Animal{}

// 자식은 부모것을 가지고 있다.
// 경찰은 무기를 가지고 있다. (has a)
class Weapon{}
class Police extends Weapon{}


public class Hello {
	public static void main(String[] args) {
		Tiger t = new Tiger();
	}
}
*/


/*
//ex44) 다형성(polymorphism)
// n차 상속이 가능하다. 다중상속은 불가.
//f4키 누르면 상속계층도를 볼 수 있다.
class A{void f1() { System.out.println(1); }}
class B extends A{void f2() { System.out.println(2); }}
class C extends B{void f3() { System.out.println(3); }}
class D extends C{void f4() { System.out.println(4); }}
class F extends A{void f5() { System.out.println(5); }}

class G extends Object{
	
}

public class Hello {
	public static void main(String[] args) {
		D t1 = new D();
		t1.f4(); //f1() f2() f3() f4()
		
		F t2 = new F();
		t2.f5(); //f1() f5()
		
		String s;
		System.out.println(t2.hashCode());
	}
}
*/


/*
//ex43) 상속 : 기존클래스가 가지고 있는 기능을 확장하는 것이다.
// 단일 책임의 원칙 : 객체지향프로그램 개발의 5대 원칙중 1개
// <SOLID원칙>
// S 단일 책임 원칙 : 한 클래스는 하나의 기능만 가지는 원칙
// O 개방 폐쇄 원칙 : 확장에는 열려있으나 수정에는 닫혀있어야 한다
// L 리스코프 치환 원칙 : 상위타입은 반드시 하위 타입으로 대체할 수 있어야 한다
// I 인터페이스 분리 원칙 : 인터페이스 내에 메소드는 최소한일 수록 좋다
// D 의존관계 역전 원칙 : 구체적인 클래스보다 추상클래스나 인터페이스에 의존해야 한다
// 부모클래스
class Tiger{
	void f1() {
		System.out.println(1);
	}
	void f3() {
		System.out.println(31);
	}
}
// 자식클래스()
class Lion extends Tiger{
	void f2() {
		System.out.println(2);
	}
	void f3() { // override(부모클래스와 자식클래스에 있는 메소드가 동일할 때)
		System.out.println(32);
	}
	void f4() {
		//this.f3(); //자식 본인
		super.f3(); //부모
	}
}
// 윗 클래스를 확장해서 사용하세요. 기존기능 + 알파
public class Hello {
	public static void main(String[] args) {
		Lion t = new Lion();
		t.f1();
		t.f2();
		t.f3(); //부모클래스와 자식클래스에 있는 메소드가 동일할 때 자식꺼 호출
		t.f4();
	}
}
*/

/*
//ex42)
class Tiger{
	Lion f1(int a, String s, Tiger t, Lion l) {
		// return l;
		return new Lion();
	}
}
class Lion{
	
}
public class Hello {
	public static void main(String[] args) {
		Tiger t = new Tiger();
		t.f1(10, "호랑이", new Tiger(), new Lion());
	}
}
*/

/*
//ex41-4) this 용법4
class Tiger{
	int money=500;
	void f1() {
		System.out.println("tiger f1 call");
		Lion lion = new Lion();
		lion.merry(this); // this == t
	}
	void f3() {
		System.out.println("tiger f3 call");
	}
}
class Lion{
	void merry(Tiger t) {
		if (t.money > 600) {
			System.out.println("ok");
		}else {
			System.out.println("ng");
		}
		System.out.println("lion f2 call");
		t.f3();
	}
}
public class Hello {
	public static void main(String[] args) {
		Tiger t = new Tiger();
		t.f1();
	}
}
*/
//2022.10.27


////////////////////////////////////////////////
//ex 41-3) this 용법3
//class Tiger {
//	int x, y;
//	Tiger() {
//		System.out.println(1);
//	}
//
//	Tiger(int a) {
//		this(); // this 생성자 메서드는 첫 줄에 있어야 한다
//		x = a * 33;
//		System.out.println(2);
//	}
//
//	Tiger(int a, int b) {
//		this(a);
//		y = b;
//		System.out.println(3);
//	}
//}
//
//public class Hello {
//	public static void main(String[] args) {
//		Tiger t = new Tiger(10, 20);
//		System.out.println(t.x + " " + t.y);
//	}
//}

//ex 41-2) this 용법2-2
//class Tiger {
//	Tiger f1() {
//		System.out.println("아침먹고");
//		return this;
//	}
//	Tiger f2() {
//		System.out.println("점심먹고");
//		return this;
//	}
//	Tiger f3() {
//		System.out.println("저녁먹고");
//		return this;
//	}
//}
//public class Hello {
//	public static void main(String[] args) {
//		Tiger t = new Tiger();
//		// 체이닝 기법을 사용하는 이유는 코드의 난입을 막는 목적
//		t.f1().f2().f3();
//		
//		// 한 세트 개념이 아니다
//		t.f1();
//		t.f2();
//		t.f3();
//		
//		// 중간에 연관이 없는 코드가 난입했다
//		t.f1();
//		System.out.println("잔다.");
//		t.f2();
//		t.f3();
//	}
//}

//ex41-2) this 용법2-1
//함수 호출 체이닝을 위해서 사용된다
//class Tiger {
//	Tiger f1() {
//		System.out.println(this.hashCode());
//		return this;
//	}
//	Tiger f2() {
//		System.out.println("f2 call");
//		return this;
//	}
//	void f3() {
//		System.out.println("f3 call");
//	}
//}
//public class Hello {
//	public static void main(String[] args) {
//		Tiger t = new Tiger();
//		System.out.println(t.hashCode());
//		Tiger t2 = t.f1();
//		System.out.println(t2.hashCode());
//		System.out.println("-------------------------------------------------");
//		
//		Tiger tiger = new Tiger();
//		// chaining 기법
//		tiger.f1().f1().f1().f2().f2().f2().f2().f2().f2().f3();;
//	}
//}

//ex41-1) this 용법1
//생성자 함수의 인수명과 필드명을 구분하기 위하여 사용한다
//class Tiger {
//	String name;
//	int age;
//
//	Tiger() {
//	}
//	Tiger(String name, int age) {
//		this.name = name;
//		this.age = age;
//	}
//	@Override
//	public String toString() {
//		return "Tiger [name=" + name + ", age=" + age + "]";
//	}
//}
//public class Hello {
//	public static void main(String[] args) {
//		Tiger t = new Tiger("홍길동", 20);
//		System.out.println(t.toString());
//	}
//}

/*
//ex40) this 정의
//this : new를 이용해서 생성된 객체를 공유하는 변수 
class Tiger {
	int num = 10;
	Tiger() {
		// this = t; 공유가 되었다
		System.out.println(this.hashCode());
	
		//this.num = 20;
		num = 20;
	}
	
	void f1() {
	}
	void f2() {
		this.f2();
	}
}

public class Hello {
	public static void main(String[] args) {
		Tiger t = new Tiger();
		System.out.println(t.hashCode());
		t.num = 20;
		
		// 참조 변수 t,t2가 가르키는 객체가 다르다
		Tiger t2 = new Tiger();
	}
}
*/

//ex39) this 예시
//class Tiger {
//	String name;
//	int age;
//	
//	Tiger() {
//	}
//	Tiger(String name, int age) {
//		this.name = name;
//		this.age = age;
//	}
//	
//	@Override
//	public String toString() {
//		return "Tiger [name=" + name + ", age=" + age + "]";
//	}
//}
//
//public class Hello {
//	public static void main(String[] args) {
//		Tiger t = new Tiger("호랑이", 10);
//		System.out.println(t.toString());
//	}
//}

//ex 38) 인수전달 생성자
//class Tiger {
//	String name;
//	int age;
//
//	Tiger() {
//		name = "홍길동";
//		age = 20;
//	}
//
//	Tiger(String n, int a) {
//		name = n;
//		age = a;
//	}
//
//	void showData() {
//		System.out.println(name + " " + age);
//	}
//
//	@Override
//	public String toString() {
//		return "Tiger [name=" + name + ", age=" + age + "]";
//	}
//}
//
//public class Hello {
//	public static void main(String[] args) {
//		Tiger t1 = new Tiger();
//		t1.showData();
//		System.out.println(t1.toString());
//
//		// 인수 전달 생성자를 만들지 않으면 생성되는 모든 객체는 같은 값을 가진다
//		Tiger t2 = new Tiger();
//		t2.showData();
//
//		Tiger t3 = new Tiger("호랑이", 40);
//		t3.showData();
//	}
//}

//ex37) 기본생성자 
////class Tiger {
////	
////}
////class Tiger {
////	Tiger() {
////	}
////}
////위 두 코드는 동일한 코드이다
////생성자가 없으면 기본 생성자를 자동으로 만들어 준다
////만약 생성자를 만들게 된다면 기본 생성자를 만들지 않는다
//class Tiger {
//	Tiger() {
//	}
//	Tiger(int num) {
//	}
//}
//
//public class Hello {
//	public static void main(String[] args) {
//		// 객체는 생성될 때 무조건 생성자를 호출한다
////		Tiger t = new Tiger();
////		System.out.println(1);
//
//		// 기본 생성자가 없기 때문에 에러가 발생한다
//		// 그래서 원칙적으로 기본 생성자를 그냥 만들어준다
//		Tiger t = new Tiger();
//		System.out.println(1);
//	}
//}

//ex36 클래스 - 생성자 
//class Tiger {
//	// 1. 생성자 : 생성자 함수
//	// 2. 생성자도 함수이기 때문에 오버로딩이 가능
//	// 3. 함수이름이 반드시 클래스 이름과 동일해야 한다
//	// 4. 인수전달을 할 수 있지만 리턴값을 가질 수 없다
//	// 5. 목적은 멤버변수초기화가 유일한 목적
//	// 6. 객체가 생성(new)될 때 자동 호출이 되고 임의로 호출할 수 없다
//	
//	// 기본 생성자
//	Tiger() { 
//		System.out.println("생성자 콜1");
//	}
//	Tiger(int num) {
//		System.out.println("생성자 콜2");
//	}
//	void f1() {
//		System.out.println("f1 call");
//	}
//	void f2() {
//		// 스스로 자신의 클래스 타입으로 객체를 만들 수 있는가 ? YES
//		Tiger t = new Tiger();
//		// 사용하는 주체가 다르다
//		t.f1();
//		f1();
//	}
//}
//
//public class Hello {
//	public static void main(String[] args) {
//		System.out.println(1);
//		Tiger t = new Tiger();
//		System.out.println(2);
//		Tiger t2 = new Tiger(100);
//		System.out.println(3);
//	}
//}

////ex35) main 메서드
//public class Hello {
//	// 생성자를 가질 수 있다
//	// 필드를 가질 수 있다
//	// 메서드를 가질 수 있다
//	int count = 100;
//	void f1() {
//		
//	}
//	void f2() {
//		System.out.println(count);
//		f1();
//	}
//	static void f3() {
//		System.out.println("f3");
//	}
//	
//	// main()에 static이 없으면 따로 Hello 객체를 생성해야 한다
//	public static void main(String[] args) {
//		// static 안에서는 static만 사용할 수 있다
////		System.out.println(count); 
////		f1();
//		f3();
//		Hello h = new Hello();
//		h.f1();
//		h.f3();
//		
//	}
//}


/*
//ex34) static : 정적(고정)!= 동적(dynamic)
//static은 처음부터 메모리에 존재한다 (객체를 생성해서 사용할 필요가 없다)
//static은 속도와 연관 (객체를 생성하는 데 오랜 시간이 소요되기 때문)
class Tiger {
	static int count;
	
	static void f1() {
		System.out.println("call 1");
	}
	
	void f2() {
		System.out.println("call 2");
	}
	
	void f3() {
		f2(); // 인스턴스 메서드는 인스턴스 메서드를 호출할 수 있다
		System.out.println("call 3");
	}
	
	static void f4() {
		// static 메서드 안에서는 static 멤버만 사용할 수 있다
		// f2(); // static 메서드는 인스턴스 메서드를 호출할 수 없다 (객체가 생성됬는지 모르기 때문)
		f1();
	}
}
public class Hello {
	public static void main(String[] args) {
		Tiger.f1();
		Tiger t = new Tiger();
		t.f2(); // 인스턴스 메서드는 객체를 생성한 이후 사용할 수 있다
		t.f1(); // 객체를 생성해서 static메서드도 사용할수는 있다
		
		// abs() 역시 static 메서드(정수 절댓값 계산)
		System.out.println(Math.abs(-100));
		// 객체를 생성할 수 없는 이유는 Math클래스의 생성자가 private로 되어있기 때문이다
		// Math m = new Math();
		System.out.println(Math.PI);
		System.out.println("----------------------------------------------------------");
		t.f3();
	}
}
*/


//ex33) 오버로딩
//class Tiger {
//	// 오버로딩 규칙
//	// 1. 전달되는 인수의 개수가 다를 때
//	// 2. 인수의 개수가 같더라도 인수타입이 다를 때
//	void show() {
//		System.out.println(1);
//	}
//
//	void show(int num) {
//		System.out.println(2);
//	}
//
//	void show(int a, int b) {
//		System.out.println(3);
//	}
//
//	void show(short num) {
//		System.out.println(4);
//	}
//}
//
//class Point {
//	int x, y;
//}
//class Rect {
//	// int width, heigh;
//	int getArea(int w, int h) {
//		return w * h;
//	}
//	int getArea(Point s, Point e) {
//		int w = e.x - s.x;
//		int h = e.y - s.y;
//		return w * h;
//	}
//	int getArea(int x1, int y1, int x2, int y2) {
//		int w = x2 - x1;
//		int h = y2 - y1;
//		return w * h;
//	}
//}
//public class Hello {
//	public static void main(String[] args) {
//		Tiger t = new Tiger();
//		t.show();
//		t.show((int) 1);
//		t.show(2, 3);
//		t.show((short) 4);
//		Rect r = new Rect();
//		System.out.println(r.getArea(3, 4));
//		System.out.println(r.getArea(3, 4, 6, 8));
//		Point p1 = new Point();
//		Point p2 = new Point();
//		p1.x = 3; 
//		p1.y = 4; 
//		p2.x = 8; 
//		p2.y = 9; 
//		
//		System.out.println(r.getArea(p1, p2));
//	}
//}
////////////////////////////////////////////////


/*
//ex32)
class Lion{
	void cry() {
		System.out.println("어흥");
	}
}
class Tiger{
	String f1() {
		//String 타입의 클래스 객체가 리턴된다.
		return "호랑이";
	}
	Lion f2() {
		Lion lion = new Lion();
		return lion; // lion >> 확보받은 메모리
	} // Lion형으로 return
}
public class Hello {
	public static void main(String[] args) {
		Tiger t = new Tiger();
		System.out.println(t.f1());
		Lion l = t.f2(); // 공유되었다.
		l.cry();
	}
}
*/

/*
//ex31)
class Lion{
	void cry() {
		System.out.println("어흥");
	}
}
class Tiger {
	// int a = 10, String b = "호랑이", ch = '책'
	// String으로 인수 전달 받았다는 것은 클래스로 전달 받았다.
	void func(int a, String b, char ch, Lion lion) {
		System.out.println(a + b + ch);
		System.out.println("2 : " + lion.hashCode()); // 동일한 객체
		lion.cry();
	}
}
public class Hello {
	public static void main(String[] args) {
		Tiger t = new Tiger();
		Lion l = new Lion();
		System.out.println("1 : " + l.hashCode());
		t.func(10, "호랑이", '책', l);
	}
}
*/


/*
//ex30)
class Tiger{
	int func() {
		return 100;
	}
	void test() {
		
	}
}
public class Hello {
	public static void main(String[] args) {
		Tiger t = new Tiger();
		
		// 1. 버린다.
		t.func();
		
		// 2. 변수로 받아서 사용
		int num=t.func();
		System.out.println(num*10);
		
		// 3. 바로 출력으로 연결.
		System.out.println(t.func());
		
		// 출력으로 연결시킬수없다.
//		System.out.println(t.test());
	}
}
*/

/*
//ex29)
class Tiger{
	// void f1()만 함수 원형(prototype)
	//1
	void f1() {
		System.out.println(1);
	}
	//2
	void f2(int a) { // 인수 전달은 1개 이상 할 수 있다.
		System.out.println(2);
	}
	//3
	int f3() { // 리턴은 1개만 할 수 있다.
		System.out.println(3);
		return 0;
	}
	//4
	int f4(int a) {
		System.out.println(4);
		return 0;
	}
}
public class Hello {
	public static void main(String[] args) {
		Tiger t = new Tiger();
		t.f1();
		t.f2(10);
		t.f3();
		t.f4(0);
	}
}
*/


/*
//ex28)
class Person {
	// 필드는 외부에 오픈시키지 않는다.
	// 데이터 은닉
	private String name="홍길동";
	private int age=20;
	
	public void setName(String n) {
		this.name=n;
	}
	public int getAge() {
		return age;
	}
	public String getName() {
		return name;
	}
	
}
public class Hello {
	public static void main(String[] args) {
		Person p1=new Person();
		p1.setName("강길동");
		System.out.println(p1.getName());
		
		// 이렇게 쓰면 안된다.
		//p1.name="강길동";
		//p1.age=30;
		//System.out.println(p1.name + " " + p1.age);
	}
}
*/


/*
//ex27)
class Tiger{
	int num;
	float count;
	String str;
}
public class Hello {
	public static void main(String[] args) {
		Tiger t1 = new Tiger();
		Tiger t2 = new Tiger();
		t1.num=10;
		t1.count=20.0f;
		t1.str="호랑이1";
		System.out.println(t1.num);
		
		t2.num=30;
		t2.count=40.0f;
		t2.str="호랑이2";
		System.out.println(t2.num);
	}
}
*/



/*
//ex26) 클래스
//클래스의 3대요소 : 생성자, 필드, 메소드
//GOF의 디자인 패턴
// 1. 파일 1개당 클래스 1개가 원칙이다.
// 2. 파일명은 클래스명과 동일하게 하는게 원칙이다.
// 3. 클래스명의 첫자는 대문자, 파일명의 첫자는 소문자
// 4. 1개의 파일에 여러개의 클래스가 들어갈 수 있는데
// 		반드시 1개만 public 이어야 한다.
// 5. Person 설계도이다.
//	1. 생성자
//	2. 필드(field) >> 변수
//	3. method     >> 함수(function)
// 6. 객체 생성 방법
// Person person = new Person();
class Person{
	
}
public class Hello {
	public static void main(String[] args) {
		// new는 메모리를 사용하는 것이다.
		Person p1 = new Person();
		Person p2 = new Person();
		Person p3 = new Person();
		System.out.println(p1.hashCode());
		System.out.println(p2.hashCode());
		System.out.println(p3.hashCode());
		
		//서로 다른 이름으로 객체를 공유했다.
		//서로 다른 이름으로 객체를 참조(reference)했다.
		//사회 : 홍길동, 집 : 곰돌이
		Person p4=p1;
		System.out.println(p4.hashCode());
		
		// 메모리 반납코드가 있어야 하는 것이 원칙인데
		// 자바는 사용하지 않는다고 판단이 되면 자동 반납이다.
		// 자바가 메모리를 가비지 콜렉션을 한다.
		
	}
}
*/
// 2022.10.26







/*
//ex25) random 세로 더하기
import java.util.Random;
public class Hello {
	public static void main(String[] args) {
		Random rn = new Random();
		int[][] arr = new int[3][4];
		int[] sum = new int[4];
		
		for (int i = 0; i < 3; i++) {
			for (int j = 0; j < 4; j++) {
				arr[i][j] = rn.nextInt(10);
			}
		}
		// 원본 출력
		for (int i = 0; i < 3; i++) {
			for (int j = 0; j < 4; j++) {
				System.out.print(arr[i][j] + " ");
			}System.out.println();
		}
		
		// 덧셈하고 출력
		for (int j = 0; j < 4; j++) {
			for (int i = 0; i < 3; i++) {
				sum[j] += arr[i][j];
			}
			System.out.print(sum[j] + " ");
		}
	}
}
*/


/*
//ex24) random
import java.util.Random;
public class Hello {
	public static void main(String[] args) {
		Random rn = new Random();
		for (int i = 0; i < 10; i++) {
			// ex1)
			// +- 20억 사이의 숫자를 랜덤하게 얻는다.
			// int num = rn.nextInt();
			// System.out.println(num);
			
			// ex2)
			// 0~9
			// 0 <= x < 10
			System.out.print(rn.nextInt(10) + " ");
		}System.out.println();
		for (int i = 0; i < 10; i++) {
			System.out.print(new Random().nextInt(100) + " ");
		}System.out.println();
		System.out.println();
		
		for (int i = 0; i < 3; i++) {
			for (int j = 0; j < 4; j++) {
				int num = rn.nextInt(10);
				System.out.print(rn.nextInt(10) + " ");
			}System.out.println();
		}
	}
}
*/



/*
//ex23)
public class Hello {
	public static void main(String[] args) {
		int[] arr = new int[3];
		int[][] brr = new int[5][3]; // [세로길이][가로길이]
		int[][][] crr = new int[2][5][3]; // [세로길이][가로길이]
		System.out.println("test1 : " + brr.length);
		System.out.println("test2 : " + brr[0].length);
		
		for (int i = 0; i < brr.length; i++) {
			for (int j = 0; j < brr[0].length; j++) {
				brr[i][j] = i*brr[0].length+j;
			}
		}
		
		for (int i = 0; i < 5; i++) {
			for (int j = 0; j < 3; j++) {
				System.out.printf("%3d", brr[i][j]);
			}System.out.println();
		}
	}
}
*/


/*
//ex22)
class Tiger{
	
}
public class Hello {
	public static void main(String[] args) {
//		String s2=new String("호랑이");
//		Tiger t1=new Tiger();
		
		String[] t1   =new String[3];
		Tiger[] t2    =new Tiger[3];
		
		String[] t31  =new String[] {new String("호"), new String("랑")};
		String[] t32  =new String[] {"호", "랑"};
		Tiger[] t4    =new Tiger[] {new Tiger(), new Tiger()};
		
		String[] t51  ={new String("호"), new String("랑")};
		String[] t52  ={"호", "랑"};
		Tiger[] t6    ={new Tiger(), new Tiger()};
		
		// 클래스 : String
		// 클래스
		// 객체지향프로그래밍
	}
}
*/





/*
//ex21)
class Tiger {
	void f1() {
		System.out.println("call");
	}
}
public class Hello {
	public static void main(String[] args) {
		Tiger[] arr = new Tiger[3];
		for (int i = 0; i < arr.length; i++) {
			arr[i] = new Tiger();
		}
		
		for (int i = 0; i < arr.length; i++) {
			arr[i].f1();
		}
		
		Tiger[] brr=new Tiger[] {
				new Tiger(), 
				new Tiger(), 
				new Tiger()
		};
		for (Tiger obj : brr) {
			obj.f1();
		}
		Tiger[] crr=new Tiger[] {
				new Tiger(), 
				new Tiger(), 
				new Tiger()
		};
	}

}
*/




/*
//ex20)
public class Hello {
	public static void main(String[] args) {
		String[] arr=new String[4];
		
		arr[0]=new String("앵무새0");
		arr[0]="앵무새0";
		
		arr[1]="앵무새1";
		arr[2]="앵무새2";
		arr[3]="앵무새3";
		String[] brr=new String[] {
			new String("호랑이"), 
			"코끼리", 
			"독수리"};
		String[] crr={"호랑이1", "코끼리1", "독수리1"};
		System.out.println(arr[2]);
		for (int i = 0; i < brr.length; i++) {
			System.out.print(brr[i] + " ");
		}System.out.println();
		for (String value : crr) {
			System.out.print(value + " ");
		}System.out.println();
	}
}
*/


/*
//ex19) 배열
public class Hello {
	public static void main(String[] args) {
		int a=10; //일반변수
		
		// array
		// 방법1
		int[] arr=new int[5];
		// 방법2
		int[] brr=new int[] {1,2,3,4};
		// 방법3
		int[] crr= {1,2,3,4,5,6};
		System.out.println(arr.length);
		System.out.println(brr.length);
		System.out.println(crr.length);
		
		for(int i=0;i<brr.length;i++) {
			System.out.print(brr[i] + " ");
		}System.out.println();
		
		// i, value, item, x
		// foreach
		for (int value : crr) {
			System.out.print(value + " ");
		}System.out.println();
		
		//
		int[] drr=new int[5];
		// 0~4
		// ArrayIndexOutOfBoundsException
		// drr[5] = 100;
		drr[2] = 100;
		drr[2*5-7] = 100;
		drr[4] = 2;
		drr[drr[4]*3-5] = 999;
	}
}
*/


/*
//ex18) 우박수 문제
public class Hello {
	public static void main(String[] args) {
		int num=1234567;
		while(true) {
			System.out.println(num);
			if(num%2==0) {
				num=num/2;
			}else {
				num=num*3+1;
			}
			
			if(num==1) {
				System.out.println(num);
				break;
			}
		}
	}
}
*/


/*
//ex17)
// for : 정확하게 반복횟수를 알고 있을 때
// while : 프로그래머가 반복횟수를 모를때...
public class Hello {
	public static void main(String[] args) {
		int num=0;
		// ex1)
		while(num<4) {
			System.out.println(num++);
		}
		// ex2)
		while(true) {
			System.out.println(num++);
			if(num==33) {
				System.out.println("탈출 일보직전");
				break;
			}
		}
	}
}
*/

/*
//ex16)
public class Hello {
	public static void main(String[] args) {
		//1. case 뒤에는 변수가 올 수 없다.
		//2. switch에는 변수를 사용할 수 있다.
		//3. case뒤에 숫자가 중복될 수 없다.
		//4. 자바 버전에 따라서 문자열/문자를 분기시킬 수 있다.
		//5. 일반적으로 case break는 한쌍인데 의도적으로 break를 생략할 수 있다.
		int num=200;
		String s="독수리";
		
		switch (s) {
		
		case "독수리":
			System.out.println(1);
			break;
		case "코끼리":
			System.out.println(1);
			break;
			
		default: break;
		}
		
		switch (s) {
		case "독수리": //break;
		case "코끼리":
			System.out.println("동물입니다.");
			break;
		case "소나무": //break;
		case "대나무":
			System.out.println("식물입니다.");
			break;
			
		default: break;
		}
		
		int jumsu=80;
		switch(jumsu/10) {
		case 10: //break;
		case 9:
			System.out.println("A");
			break;
		case 8:
			System.out.println("B");
			break;
		default:
			break;
		}
	}
}
*/



//ex15) for in for
//public class Hello {
//	public static void main(String[] args) {
//		// ex1)
//		// 격자형태(테이블형태, 맵형태)
//		for(int i=0;i<3;i++) {
//			for (int j = 0; j < 4; j++) {
//				System.out.print("[" + i + " " + j + "]");
//			}
//			System.out.println();
//		}System.out.println();
//		
//		// ex2)
//		// 격자형태(테이블형태, 맵형태)
//		for(int i=0;i<3;i++) {
//			for (int j = 0; j < 4; j++) {
//				System.out.print(" * ");
//			}
//			System.out.println();
//		}System.out.println();
//		
//		// ex3)
//		int width=4, height=3;
//		for(int i=0;i<height;i++) {
//			for (int j = 0; j < width; j++) {
////				System.out.print(i*width+j);
//				System.out.printf("%2d", i*width+j);
//			}
//			System.out.println();
//		}System.out.println();
//		
//		System.out.printf( "호랑이\n" );
//		System.out.printf( "코끼리\n" );
//		System.out.printf( "코%d끼%d리%d\n", 777, 888, 999 );
//		System.out.printf("%d\n", 3);
//		System.out.printf("%4d\n", 3);
//		System.out.printf("%04d\n", 3);
//		
//		int a=10, b=20, c=30;
//		String s = String.format("무궁화:%d 소나무:%d 백합:%d", 10, 20, 30);
//		System.out.println("output : " + s);
//		
//		//ex4)
//		for(int i=0;i<3;i++)
//			for(int j=0;j<4;j++)
//				System.out.println("test");
//		
//		//ex5)
//		for(int i=0;i<3;i++) {
//			for(int j=0;j<4;j++)
//				System.out.println("apple");
//			
//			System.out.println("banana");
//		}
//		
//		//ex6)
//		//for(int i=0;i<3;i++);
//		int count;
//		for(count=0; count<3; count++);
//		
//		System.out.println(count);
//	}
//}


//ex14)
//public class Hello {
//	// int a = n1++;
//	// int b = ++n2;
//	static void f1(int a, int b) {
//		System.out.println(a + " " + b);
//	}
//	public static void main(String[] args) {
//		int a = 3;
//		int b = a++; //1. 대입 2. 증가
//		System.out.println(a + " " + b);
//		
//		int c = 3;
//		int d = ++c; //1. 증가 2. 대입
//		System.out.println(c + " " + d);
//		int n1=3, n2=3;
//		System.out.println("-------------------------");
//		f1(n1++, ++n2);
//		n1++;
//		++n2;
//		// 자료가 10이 있을때
//		// 이 자료를 순회하면서 하나씩 가져오거나 저장할때
//		// 일반적으로 이터레이터를 사용하게 되는데
//		// 이터레이터 연산 중에서
//		// 이터레이터++
//		// ++이터레이터
//		// 라는 두 명령이 존재한다.
//		// 이때 두 명령의 실행속도는 30배정도 차이가 난다.
//		// ++이터레이터가 30배정도 빠르다.
//		// 그래서
//	}
//}

//ex13)
//public class Hello {
//	public static void main(String[] args) {
//		// 1만 증가 시킨다는 전제 아래에서
//		int num=0;
//		//대입연산과 덧셈연산이 사용된다.
//		// move, add 어셈블리어로 번역
//		num=num+1;
//		System.out.println(num);
//		// inc
//		// num++, ++num은 속도가 똑같다.
//		num++;
//		System.out.println(num);
//		++num;
//		System.out.println(num);
//		
//		num+=1; // 약간 좋다.
//		System.out.println(num);
//		
//		int test=10;
//		int count=20;
//		test+=count;
//		// test = test + count;
//	}
//}


//ex12)
//public class Hello {
//	public static void main(String[] args) {
//		char ch = 'A'; //문자 'A'의 아스키코드값은 65
//		// println ch가 무슨 타입인지 확인한다.
//		// 문자타입이라고 확인하고 숫자를 아스키문자로 출력한것이다.
//		System.out.println(ch);
//		// 강제 형 변환(단, 현재 라인에서만 적용된다.)
//		// 강제 형 변환(타입캐스팅)
//		System.out.println((int)ch);
//		System.out.println(65);
//		System.out.println((char)65);
//		int num = 65;
//		System.out.println(num);
//		System.out.println((char)num);
//		System.out.println("-------------------------");
//		
//		char ch2='A';
//		for(int i=0;i<26;i++) {
//			System.out.println((char)(ch2+i));
//		}
//	}
//}


//ex11)
//public class Hello {
//	public static void main(String[] args) {
//		// 기본코드1
//		int num=5;
//		for(int i=0;i<10;i++) {
//			System.out.println(num+ " * " + i + " = " + num*i);
//		}
//		// 기본코드2
//		int sum=0;
//		num = 10;
//		for (int i = 0; i <= num; i++) {
//			//sum = sum + i;
//			sum+=i; // 복합대입연산자
//		}
//		System.out.println(sum);
//		
//	}
//}



// ex10) for
//public class Hello {
//	public static void main(String[] args) {
//		// 정석코드1
//		for (int i = 0; i < 4; i++) {
//			System.out.println(i);
//		}
//		// 정석코드2
//		for (int i = 1; i <= 4; i++) {
//			System.out.println(i);
//		}
//		// 정석코드3
//		// 4*2+1번
//		int aa=4;
//		for (int i = -aa; i <= aa; i++) {
//			System.out.println(i);
//		}
//		// bad code
//		for(int i=0;i<=4;i++) {
//			System.out.println(i);
//		}
//		for(int i=2;i<=4;i++) {
//			System.out.println(i);
//		}
//		for(int i=2;i<=4;i+=2) {
//			System.out.println(i);
//		}
//		for(int i=2;i>4;i+=2) {
//			System.out.println(i);
//		}
//	}
//}



// ex9) if
//public class Hello {
//	public static void main(String[] args) {
//		// if for while switch
//		
//		// ex1)
//		// if(true)
//		// if(3>2)
//		// if(true||false)
//		if(true) {
//			System.out.println(1);
//			System.out.println(2);
//		}
//		// scope 생략 가능
//		if(true)
//			System.out.println(3);
//		
//		// ex2)
//		int num=10;
//		if(num%2==0) {
//			System.out.println("짝수");
//		}else {
//			System.out.println("홀수");
//		}
//		
//		// ex3) n개중에 1개를 선택
//		if(false) {
//			System.out.println(10);
//		}else if(false) {
//			System.out.println(20);
//		}else if(true) {
//			System.out.println(30);
//		}else {
//			System.out.println(40);
//		}
//		
//		// ex4)
//		if(true) {
//			if(false) {
//				if(true) {
//					
//				}
//			}else {
//				if(true) {
//					
//				}else if(false) {
//					
//				}else {
//					
//				}
//			}
//		}
//	}
//}


// ex8) 논리연산(관계연산)
//public class Hello {
//	public static void main(String[] args) {
//		// and(&&), or(||), not(부정)
//		System.out.println(false && false);
//		System.out.println(false && true);
//		System.out.println(true && false);
//		System.out.println(true && true);
//		System.out.println("------------------");
//		System.out.println(false || false);
//		System.out.println(false || true);
//		System.out.println(true || false);
//		System.out.println(true || true);
//		System.out.println("------------------");
//		boolean test=true;
//		System.out.println(!test);
//		System.out.println(!(10>20));
//		
//		System.out.println( true && true && true && false );
//		System.out.println( !(false && true && false && false) );
//		
//		// 연산자 우선순위 : 산술 > 관계(비교) > 논리
//		System.out.println(
////			3+2>2 && 4-2<10 && 3*3>=8
////			5>2 && 2<10 && 9>=8
////			true && true && true
//				);
//		// 아래 프로그램은 잘못 작성된 예이다.
//		// 코드의 가독성이 떨어진다.
//		// System.out.println(true && true || true);
//		// 연산자 우선순위를 결정해서 적어주는 것이 좋다.
//		System.out.println((true && true) || true);
//		System.out.println(true && (true || true));
//		
//		
//	}
//}


//ex7) 비교연산(관계연산)
//public class Hello {
//	public static void main(String[] args) {
//		// 산술연산
//		System.out.println(3>2);
//		System.out.println(3<2);
//		System.out.println(3>=2);
//		System.out.println(3<=2);
//		System.out.println(3==2);
//		System.out.println(3!=2);
//		
//		
//	}
//}



// ex6) 산술연산/문자열 연결
//public class Hello {
//	public static void main(String[] args) {
//		System.out.println(27 + 4);
//		System.out.println(27 - 4);
//		System.out.println(27 * 4);
//		System.out.println(27 / 4); //몫
//		// result : 0 ~ 3
//		System.out.println(27 % 4); //나머지
//		
//		System.out.println(27+4);
//		// 왼쪽에서 오른쪽으로 해석한다.
//		// 숫자 + 문자열 = 문자열
//		// 문자열 + 숫자 = 문자열
//		// 문자열 + 문자열 = 문자열
//		System.out.println(27+"호랑이");
//		System.out.println("호랑이"+27);
//		System.out.println("호랑이" + "코끼리");
//		System.out.println(27+13+"호랑이");
//		System.out.println(40+"호랑이");
//		System.out.println("호랑이" + 27 + 13);
//		System.out.println(27 + "호랑이" + 13);
//		System.out.print(27 + " " + 13);
//		int a = 10, b = 20;
//		System.out.println(a + " " + b);
//		// 문자 : 1개
//		// 문자열 : 0개이상
//	}
//}
//


// ex5) 표기법 정리
//public class Hello {
//	public static void main(String[] args) {
//		// 카멜표기법
//		int appleNum = 10;
//		// 파스칼표기법 : 맨앞에 오는 글자 대문자로 표기 + 카멜표기법
//		int TotalNumber = 10;
//		// 헝가리안표기법 : 접두어에 자료형을 알아볼 수 있게 표기
//		String strName;
//		// 스네이크 표기법 : 단어 사이에 언더바를 넣어서 표기
//		int total_number;
//	}
//}


// ex4)
//public class Hello {
//	public static void main(String[] args) {
//		short a = 200;
//		System.out.println(Short.MAX_VALUE);
//		System.out.println(Short.MIN_VALUE);
//		System.out.println(Long.MAX_VALUE);
//		System.out.println(Long.MIN_VALUE);
//		System.out.println(Integer.MAX_VALUE);
//		System.out.println(Integer.MIN_VALUE);
//		System.out.println(Character.MAX_VALUE);
//		System.out.println(Character.MIN_VALUE);
//		
//		int b = 10;
//		if (b < Short.MAX_VALUE) {
//			
//		}
//	}
//}

// ex03)
//public class Hello {
//	public static void main(String[] args) {
//		// type(형) int
//		// >> int, double, float, short, long, char, boolean, byte
//		// 8가지
//		// byte(1) : +- 127
//		// short(2) : +- 3xxxx
//		// char(2) : 문자 전용(0~65535)
//		// int(4) : 정수 전용 2^32(+- 20억)
//		// long(8) : 8byte 정수
//		// float(4) : 실수 전용(3.14)
//		// double(8) : 8byte 실수
//		// boolean(1) : true/false
//		
//		int a = 10;
//		double sum = 0.0;
//		for (int i=0;i<100;i++) {
//			sum+=0.1f;
//		}
//		System.out.println(sum);
//		
//	}
//}
// 2022.10.25

// ex1) 환경설정
// ex2) 
//public class Hello {
//	public static void main(String[] args) {
//		System.out.println("호랑이1");
//		System.out.println("호랑이2");
//		System.out.println("호랑이3");
//		System.out.println("호랑이4");	
//	}
//}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-28 14:18:15.291
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-28 14:18:15.292
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-28 14:18:17.615
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package Pack01;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.Random;
import java.util.Scanner;

// ex)
//public class Hello {
//	public static void main(String[] args) {
//		
//	}
//}


//ex65)
public class Hello {
	static String hexaToBinary(int n) {
		String result = Integer.toBinaryString(n);
		
		while(result.length() < 32) {
			result = "0" + result;
		}
		StringBuffer result1 = new StringBuffer(result);
		for (int i = 0; i < 7; i++) {
			result1.insert((7-i)*4, " ");
		}
		return result1.toString();
	}
	
	public static void main(String[] args) {
		// ARGB
		int num = 0x3b12cd59;
		//        0x3b12cd59; A
		//      & 0x00ff0000; M
		//        0x00120000; R
		//  >> 16 0x00000012;
		System.out.println(hexaToBinary(num));
		System.out.println(hexaToBinary(0x00ff0000));
		System.out.println(hexaToBinary(num & 0x00ff0000));
		System.out.println(hexaToBinary((num & 0x00ff0000) >> 16));
		int Red = (num & 0x00ff0000) >> 16;
		System.out.println(Red);
		
		int Green = (num & 0x0000ff00) >> 8;
		System.out.println(Green);
		
		int Blue = (num & 0x000000ff);
		System.out.println(Blue);
		
		(Red << 16) || (Green << 8) || Blue
	}
}



/*
//ex64) 비트 연산
public class Hello {
	static String hexaToBinary(int n) {
		String result = Integer.toBinaryString(n); //111011000100101100110101011001
		//System.out.println("1 : " + result.length());
		
		while(result.length() < 32) {
			result = "0" + result;
		}
		//System.out.println("2 : " + result);
		
		StringBuffer result1 = new StringBuffer(result); // StringBuffer는 갱신을 할수있다
		//System.out.println("3 : " + result1);
		
		for (int i = 0; i < 7; i++) {
			result1.insert((7-i)*4, " ");
		}
		//System.out.println("4 : " + result1); //0011 1011 0001 0010 1100 1101 0101 1001
		return result1.toString(); //StringBuffer를 String으로 변환해준다(return값이 String이므로)
	}
	
	public static void main(String[] args) {
		// 앞에 0x가 붙으면 뒤에는 16진수가 된다 / 0만 붙으면 뒤에는 8진수가 된다
		// 진법 : 2진법, 10진법, 16진법(개인적으로 익히기)
		// 16진법 : 0 1 2 3 4 5 6 7 8 9 A  B  C  D  E  F
		//                           10 11 12 13 14 15
		int num = 0x3b12cd59; //16진수를 2진수로 바꿔보자!
		// 이진수 : 11 1011 0001 0010 1100 1101 0101 1001
		// 끝에서부터 4자리씩 끊고 앞에 공백에 0채워넣기
		// 0011 1011 0001 0010 1100 1101 0101 1001
		String result = Integer.toBinaryString(num); //111011000100101100110101011001
		System.out.println(result);
		
		//직접 함수 만들어서 네자리씩 끊기
		System.out.println(hexaToBinary(num));
	}
}
*/


/*
//ex63-2) 제네릭 문법
// class 개수를 줄이는 건 아님(class는 사용할때마다 내부적으로 생성된다) - 보이는 코드길이만 줄어듦
class Tiger<T>{
	private T data;
	
	public T getData() {
		return data;
	}
	public void setData(T data) {
		this.data=data;
	}
}
public class Hello {
	public static void main(String[] args) {
		// Tiger<Integer> t = new Tiger<Integer>();
		Tiger<Integer> t1 = new Tiger<>();
		t1.setData(100);
		System.out.println(t1.getData());
		
		
		Tiger<String> t2 = new Tiger<>();
		t2.setData("호랑이");
		System.out.println(t2.getData());
		
		
		Tiger<Float> t3 = new Tiger<>();
		t3.setData(3.14f);
		System.out.println(t3.getData());
		
		LinkedList<String> mm = new LinkedList<>();
		
	}
}
*/


/*
//ex63-1) 제네릭이 필요한 이유를 설명한 코드
class Tiger{
	private int data;
	
	public int getData() {
		return data;
	}
	public void setData(int data) {
		this.data=data;
	}
}
class Lion{
	private String data;
	
	public String getData() {
		return data;
	}
	public void setData(String data) {
		this.data=data;
	}
}
public class Hello {
	public static void main(String[] args) {
		Tiger t = new Tiger();
		t.setData(100);
		System.out.println(t.getData());
		
		Lion l = new Lion();
		l.setData("호랑이");
		System.out.println(l.getData());
	}
}
*/



/*
//ex62) annotation(@)
class A{
	void showMeTheMoney() {
		
	}
}

class B extends A{
	// @Override를 붙이는 이유(annotation)
	// : 이렇게 오타를 발생시키고 override를 하면 오류발생을 알려줌
//	@Override
//	void ShowMeTheMoney() {
//		System.out.println(2);
//	}
}

interface C{
	void f1();
}
class D implements C{
	// 코드 자동 완성을 이용하였다.(ctrl+space)
	@Override
	public void f1() {
		// TODO Auto-generated method stub
		
	}
}

public class Hello {
	public static void main(String[] args) {
		A a = new B();
		a.showMeTheMoney();
	}
}
*/


/*
//ex61) Collection
// CRUD(Create, Read, Update, Delete)에 맞게 알맞은 자료구조를 선택해서 사용해야함
// List(순서가 있음) - LinkedList, Stack, Vector, ArrayList
// Set(중복X) - HashSet, SortedSet-TreeSet
// Map(key:value) - Hashtable, HashMap, SortedMap-TreeMap

// LinkedList - 평균적으로 좋은 것, 추가, 삭제에 좋음, but 검색에 취약함
// 나머지는 각자 시간날때 해볼것!
// Queue Interface는 PriorityQueue, Deque, ArrayDeque

// Collection 중 LinkedList의 예시
public class Hello {
	public static void main(String[] args) {
		// <저장할 데이터 타입>
		// 반드시 클래스 타입만 가능하다.(LinkedList<int> 이런건 안됨)
		// LinkedList<Integer> mm = new LinkedList<Integer>();
		LinkedList<Integer> mm = new LinkedList<>();
		System.out.println(mm.size());
		
		// (Create)RUD
		mm.add(100);
		for (int i = 0; i < 10; i++) {
			mm.add(i*10+i);
		}
		System.out.println(mm.size() + "개 있다");
		
		// C(Read)UD
		// 방법1 : 활용성이 없다.(당장은 편하지만)
		System.out.println(mm);
		
		// 방법2 : 
		for (int i = 0; i < mm.size(); i++) {
			System.out.print(mm.get(i) + " ");
		}System.out.println();
		
		// 방법 : forEach :
		// i, data, x, value, item
		for (Integer value : mm) {
			System.out.print(value + " ");
		}System.out.println();
		
		int[] ar = {1, 2, 3};
		for (int value : ar) {
			System.out.print(value + " ");
		}System.out.println();
		
		System.out.println(mm.get(5));
		
		// CR(Update)D
		mm.set(5, 2022);
		System.out.println(mm);
		
		// CRU(Delete)
		mm.remove(4);
		System.out.println(mm);
		
		// C : create, insert, add
		// R : read, select, get
		// U : update, set
		// D : delete, remove, erase, clear
	}
}
*/
//2022.10.28


/*
//ex60) String
public class Hello {
	public static void main(String[] args) {
		String s = "무궁화꽃이피었습니다";
		
		// 1) 문자열 길이
		System.out.println(s.length()); //10
		
		// 2) 해당 인덱스의 문자
		System.out.println(s.charAt(3)); //꽃
		
		// 3) 해당 문자열의 시작인덱스(정확하게 일치하는 문자열이 포함되어있을때만)
		System.out.println(s.indexOf("궁화")); //1
		System.out.println(s.indexOf("나무")); //-1(포함X)
		if(s.indexOf("나무")==-1) {
			System.out.println("not found");
		}else {
			System.out.println("find");
		}
		
		// 4) 해당 문자열1을 해당 문자열2로 대체해서 출력함(단, 원본은 안바뀜)
		System.out.println(s.replace("꽃이", "나무가")); //무궁화나무가피었습니다
		System.out.println(s); //무궁화꽃이피었습니다
		String newString = s.replace("꽃이", "식물이");
		System.out.println(newString); //무궁화식물이피었습니다
		
		// 5) 해당 인덱스부터 끝까지 자른다(끝범위도 지정 가능)
		System.out.println(s.substring(3)); //꽃이피었습니다
		System.out.println(s.substring(3, 5)); //꽃이
		//(a, b) >> a부터 b-1까지
		
		
		// 그 외 String 클래스 메소드(실습)
		// 문자열에 이어붙이기(원본이 바뀌진 않음)
		System.out.println(s.concat("안녕")); //무궁화꽃이피었습니다안녕
		System.out.println(s); //무궁화꽃이피었습니다
		
		// 문자열에 해당 문자열이 포함되어있는지 true/false로 출력
		System.out.println(s.contains("궁")); //true
		System.out.println(s.contains("안")); //false
		
		// 문자열이 해당 문자열로 끝나는지 true/false로 출력
		System.out.println(s.endsWith("다")); //true
		System.out.println(s.endsWith(".")); //false
		
		// 문자열이 해당 문자열과 완전히 같은지 true/false로 출력
		System.out.println(s.equals("무궁화꽃이피었습니다")); //true
		System.out.println(s.equals("무궁화")); //false
		
		// 해당 문자열이 빈 문자열인지 true/false로 출력
		System.out.println(s.isEmpty()); //false
		System.out.println("".isEmpty()); //true
		
		// 문자열을 해당 문자열로 완전히 대체함(원본은 바뀌지 않음)
		System.out.println(s.replaceAll(s, "안녕")); //안녕
		System.out.println(s); //무궁화꽃이피었습니다
		
		// 문자열을 해당 문자열을 기준으로 나눠준다(원본은 바뀌지 않음)
		System.out.println(s.split("이")[0]); //무궁화꽃
		System.out.println(s.split("이")[1]); //피었습니다
		System.out.println(s); //무궁화꽃이피었습니다
		
		// 문자열을 소문자, 대문자로 바꿔준다(원본은 바뀌지 않음)
		String str = "aBcDefgH";
		System.out.println(str.toLowerCase()); //abcdefgh
		System.out.println(str.toUpperCase()); //ABCDEFGH
		System.out.println(str); //aBcDefgH
		
		// 문자열의 왼쪽, 오른쪽 공백을 제거해준다(가운데 공백들은 제거X)
		String str2 = " a b  c   d ";
		System.out.println(str2.trim()); //a b  c   d
	}
}
*/

/*
//ex59) Scanner(입력)
public class Hello {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.println("숫자를 입력하세요");
		int num = sc.nextInt();
		System.out.println("입력된 숫자는 : " + num + "입니다.");
	}
}
*/


/*
//ex58) Thread.sleep()
public class Hello {
	public static void main(String[] args) {
		System.out.println(1);
		
		for (int i = 0; i < 5; i++) {
			
			// 특정 조건 만족한 이후에 함수실행을 끝내는 이러한 함수를
			// 블로킹함수.
			try {Thread.sleep(3000);} catch (InterruptedException e) {}
			System.out.println(i*10);
		}
		
		System.out.println(2);
	}
}
*/


/*
//ex57)
class Tiger{
	void f1() {
		System.out.println(1);
		
		try {
			throw new Exception();			
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	// 이 함수를 호출한 게 Exception을 catch함
	void f2() throws Exception{
		System.out.println(2);
		throw new Exception();
	}
}
public class Hello {
	public static void main(String[] args) {
		Tiger t = new Tiger();
		t.f1();
		
		// Unhandled exception type Exception
		try {
			t.f2();			
		} catch (Exception e) {
			e.printStackTrace();
		}
		System.out.println("end");
	}
}
*/


/*
//ex56) 예외처리(exception)
public class Hello {
	public static void main(String[] args) {
		
		// 1. Arithmetic Exception
		try {
			System.out.println(4/0);
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		// 2. ArrayIndexOutOfBoundsException
		int[] ar = new int[3];
		try {
			ar[3] = 10;			
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		// 3. NullPointerException
		String str = null;
		try {
			System.out.println(str.length());			
		} catch (Exception e) {
			e.printStackTrace();
		}

		System.out.println("무궁화꽃이피었습니다.");
	}
}
*/


/*
//ex55) 삼항연산
public class Hello {
	public static void main(String[] args) {
		
		// ex1
		int num1;
		if(true) {
			num1 = 10;
		}else {
			num1 = 20;
		}
		
		num1 = true ? 10 : 20;
		
		// ex2
		if (true) {
			System.out.println("호랑이");
		}else {
			System.out.println("코끼리");
		}
		
		System.out.println(true ? "호랑이" : "코끼리");
		
		Tiger t = new Tiger();
		t.f1(3, 4);
		
		
		// 우박수 문제(삼항연산자로 표현)
		int num=1234567;
		while(true) {
			System.out.println(num);
			num = (num%2==0) ? num/2 : num*3+1;
			
			if(num==1) {
				System.out.println(num);
				break;
			}
		}

	}
}
class Tiger{
	int f1(int a, int b) {
//		if(a > b) {
//			return 1000;
//		}else {
//			return 2000;
//		}
		return a > b ? 1000 : 2000;
	}
}
*/


/*
//ex54)
interface Animal{
	abstract void cry();
}
class Dog implements Animal{
	public void cry() {System.out.println("멍멍");}
}
class Cat implements Animal{
	public void cry() {System.out.println("야옹");}
}
public class Hello {
	public static void main(String[] args) {
		Animal t = new Dog();
		t.cry();
	}
}
*/

/*
//ex53)
class Animal{
	void cry() {System.out.println("잉잉");}
}
class Dog extends Animal{
	void cry() {System.out.println("멍멍");}
}
class Cat extends Animal{
	void cry() {System.out.println("야옹");}
}
class Snake extends Animal{
	// cry() 구현없으면 부모를 따른다.
}
public class Hello {
	public static void main(String[] args) {
//		Dog t1 = new Dog();
//		Cat t2 = new Cat();
//		Snake t3 = new Snake();
//		
//		for (int i = 0; i < 5; i++) {
//			switch (new Random().nextInt(3)) {
//			case 0: t1.cry(); break;
//			case 1: t2.cry(); break;
//			case 2: t3.cry(); break;
//			default: break;
//			}			
//		}
//		int a, b, c;
//		int[] ar = new int[3];
//		Animal[] ani = new Animal[3];
//		ani[0] = new Dog();
//		ani[1] = new Cat();
//		ani[2] = new Snake();
		
		
// 		위의 코드와 동일한 코드이다.(이렇게 줄일수있다.)
		Animal[] ani = new Animal[] { new Dog(), new Cat(), new Snake()};
		for (int i = 0; i < 5; i++) {
			ani[new Random().nextInt(3)].cry();			
		}
	}
}
*/


/*
//ex52)업캐스팅을 하는 이유
class Animal{
	void cry() {
		System.out.println("잉잉");
	}
}
class Dog extends Animal{
	void cry() {
		System.out.println("멍멍");
	}
}
class Cat extends Animal{
	void cry() {
		System.out.println("야옹");
	}
}
class Snake extends Animal{
	// cry() 구현없으면 부모를 따른다.
}
class Zoo{
	// 1. upcasting을 하게 되면 이렇게 하나만으로 모든 cry() 동작을 할 수 있다
	// Animal ani = new Dog(), new Cat(), new Snake()
	void sound(Animal ani) {
		ani.cry();
	}
	
	
	// 2. upcasting을 안하게 되면 이렇게 동물이 추가될때마다 cry()를 추가해야함
	void sound(Dog dog) {
		dog.cry();
	}
	void sound(Cat cat) {
		cat.cry();
	}
	void sound(Snake snake) {
		snake.cry();
	}
}
public class Hello {
	public static void main(String[] args) {
		Animal t1 = new Dog();
		Animal t2 = new Cat();
		Animal t3 = new Snake();
		t1.cry();
		t2.cry();
		t3.cry();
		System.out.println("--------------------");
		
		Dog t4 = new Dog();
		Cat t5 = new Cat();
		Snake t6 = new Snake();
		t4.cry();
		t5.cry();
		t6.cry();
		System.out.println("--------------------");
		
		Zoo zoo = new Zoo();
		zoo.sound(new Dog());
		zoo.sound(new Cat());
		zoo.sound(new Snake());
	}
}
*/


/*
//ex51) 다형성(업캐스팅)
// 클래스의 결과나 인터페이스나 동일하다.
class A{
	void f1() {
		System.out.println(1);
	}
	void f2() {
		System.out.println(2);
	}
	void f3() {
		System.out.println("f3 call");
		f4(); // 자식꺼에도 있으면 부모꺼가 아닌 자식꺼를 실행시킨다.
	}
	void f4() {
		System.out.println("부모 f4");
	}
}
class B extends A{
	void f2() {
		System.out.println(3);
	}
	void f4() {
		System.out.println("자식 f4");
	}
}
public class Hello {
	public static void main(String[] args) {
		// 부 = 자
		A t = new B();
		t.f1();
		t.f2();
		t.f3();
	}
}
*/



/*
//ex50) 다형성
class A{
	void f1() {}
}

class B extends A{
	void f2() {}
}

public class Hello {
	public static void main(String[] args) {
		// 좌변은 문법 구사 / 우변은 할당메모리를 의미함
		// 상속과는 무관하다.
		A t1 = new A();
		t1.f1();
		
		
		// up casting(업캐스팅)
		A t2 = new B(); //문법적으로는 A만, 할당된 메모리는 둘다(가능)
		t2.f1();
		
		
		// 자바에서 지원하지 않는다.(다운캐스팅)
//		B t3 = new A(); // 문법적으로는 A,B 둘다, 할당된메모리는 A만(오류)
		
		
		// 자식것을 보고 없으면 부모것을 살펴본다.
		B t4 = new B();
		t4.f1();
		t4.f2();
	}
}
*/

/*
//ex49-2)
class A {void f1() {System.out.println(1);}}
interface B{void f2();}
interface C{void f3();}
class D extends A implements B, C{
	public void f2() {System.out.println(2);}
	public void f3() {System.out.println(3);}
}
public class Hello {
	public static void main(String[] args) {
		D t = new D();
		t.f1();
		t.f2();
		t.f3();
		
		StringBuffer sb;
	}
}
*/


/*
//ex49-1)
interface A{
	void f1();
}
interface B{
	void f2();
}
class C implements A, B{
	public void f1() {System.out.println(1);}
	public void f2() {System.out.println(2);}
}
public class Hello {
	public static void main(String[] args) {
		C t = new C();
		t.f1();
		t.f2();
	}
}
*/


/*
//ex48)
// abstract : 클래스이기 때문에 다중상속을 할 수 없다.
// interface 동일한 조건일때는 interface를 선택(다중상속을 할 수 있다.)
interface Tiger{
	abstract void f1();
	void f2();
}
class Lion implements Tiger{
	// interface에 있는 것을 구현한 함수는 반드시 public 이어야 한다.
	public void f1() {	System.out.println(1);}
	public void f2() {	System.out.println(2);}
}
public class Hello {
	public static void main(String[] args) {
		Lion t = new Lion();
		t.f1();
		t.f2();
	}
}
*/

/*
//ex47)
abstract class 대장장이{
	void 칼() {
		System.out.println("칼 만듦");
	}
	abstract void 방패();
}
class 병사1 extends 대장장이{
	void 방패() {
		System.out.println("드래곤이빨 방패 구해서 사용함");
	}
}
class 병사2 extends 대장장이{
	void 방패() {
		System.out.println("나무 방패 구해서 사용함");
	}
}
public class Hello {
	public static void main(String[] args) {
		병사1 t1 = new 병사1();
		t1.칼();
		t1.방패();
		병사2 t2 = new 병사2();
		t2.칼();
		t2.방패();
	}
}
*/

/*
//ex46)
abstract class Tiger{
	// 추상 함수이다.
	// 추상 함수를 1개라도 가지는 클래스는 반드시 추상 클래스이어야 한다.
	abstract void f1(); // 미완성코드(abstract : 추상)
	
	// 완성된 코드
	void f2() {
		System.out.println(1);
	}
}

// 상속받은 자식은 반드시 부모의 미완성코드를 완성해야 한다.
// 오버라이드(override) 문법을 이용해서
class Lion extends Tiger{
	void f1() {
		System.out.println(2);
	}
}

public class Hello {
	public static void main(String[] args) {
		// 추상 클래스는 객체 생성을 할 수 없다.
		// Tiger t = new Tiger();(X)
		Lion t = new Lion();
		t.f1();
		t.f2();
	}
}
*/

/*
//ex45)
// 자식은 부모이다.
// 사자는 호랑이이다.(X)
// 사자는 동물이다.(O) (is a)
class Tiger{}
class Animal{}
class Lion extends Animal{}

// 자식은 부모것을 가지고 있다.
// 경찰은 무기를 가지고 있다. (has a)
class Weapon{}
class Police extends Weapon{}


public class Hello {
	public static void main(String[] args) {
		Tiger t = new Tiger();
	}
}
*/


/*
//ex44) 다형성(polymorphism)
// n차 상속이 가능하다. 다중상속은 불가.
//f4키 누르면 상속계층도를 볼 수 있다.
class A{void f1() { System.out.println(1); }}
class B extends A{void f2() { System.out.println(2); }}
class C extends B{void f3() { System.out.println(3); }}
class D extends C{void f4() { System.out.println(4); }}
class F extends A{void f5() { System.out.println(5); }}

class G extends Object{
	
}

public class Hello {
	public static void main(String[] args) {
		D t1 = new D();
		t1.f4(); //f1() f2() f3() f4()
		
		F t2 = new F();
		t2.f5(); //f1() f5()
		
		String s;
		System.out.println(t2.hashCode());
	}
}
*/


/*
//ex43) 상속 : 기존클래스가 가지고 있는 기능을 확장하는 것이다.
// 단일 책임의 원칙 : 객체지향프로그램 개발의 5대 원칙중 1개
// <SOLID원칙>
// S 단일 책임 원칙 : 한 클래스는 하나의 기능만 가지는 원칙
// O 개방 폐쇄 원칙 : 확장에는 열려있으나 수정에는 닫혀있어야 한다
// L 리스코프 치환 원칙 : 상위타입은 반드시 하위 타입으로 대체할 수 있어야 한다
// I 인터페이스 분리 원칙 : 인터페이스 내에 메소드는 최소한일 수록 좋다
// D 의존관계 역전 원칙 : 구체적인 클래스보다 추상클래스나 인터페이스에 의존해야 한다
// 부모클래스
class Tiger{
	void f1() {
		System.out.println(1);
	}
	void f3() {
		System.out.println(31);
	}
}
// 자식클래스()
class Lion extends Tiger{
	void f2() {
		System.out.println(2);
	}
	void f3() { // override(부모클래스와 자식클래스에 있는 메소드가 동일할 때)
		System.out.println(32);
	}
	void f4() {
		//this.f3(); //자식 본인
		super.f3(); //부모
	}
}
// 윗 클래스를 확장해서 사용하세요. 기존기능 + 알파
public class Hello {
	public static void main(String[] args) {
		Lion t = new Lion();
		t.f1();
		t.f2();
		t.f3(); //부모클래스와 자식클래스에 있는 메소드가 동일할 때 자식꺼 호출
		t.f4();
	}
}
*/

/*
//ex42)
class Tiger{
	Lion f1(int a, String s, Tiger t, Lion l) {
		// return l;
		return new Lion();
	}
}
class Lion{
	
}
public class Hello {
	public static void main(String[] args) {
		Tiger t = new Tiger();
		t.f1(10, "호랑이", new Tiger(), new Lion());
	}
}
*/

/*
//ex41-4) this 용법4
class Tiger{
	int money=500;
	void f1() {
		System.out.println("tiger f1 call");
		Lion lion = new Lion();
		lion.merry(this); // this == t
	}
	void f3() {
		System.out.println("tiger f3 call");
	}
}
class Lion{
	void merry(Tiger t) {
		if (t.money > 600) {
			System.out.println("ok");
		}else {
			System.out.println("ng");
		}
		System.out.println("lion f2 call");
		t.f3();
	}
}
public class Hello {
	public static void main(String[] args) {
		Tiger t = new Tiger();
		t.f1();
	}
}
*/
//2022.10.27


////////////////////////////////////////////////
//ex 41-3) this 용법3
//class Tiger {
//	int x, y;
//	Tiger() {
//		System.out.println(1);
//	}
//
//	Tiger(int a) {
//		this(); // this 생성자 메서드는 첫 줄에 있어야 한다
//		x = a * 33;
//		System.out.println(2);
//	}
//
//	Tiger(int a, int b) {
//		this(a);
//		y = b;
//		System.out.println(3);
//	}
//}
//
//public class Hello {
//	public static void main(String[] args) {
//		Tiger t = new Tiger(10, 20);
//		System.out.println(t.x + " " + t.y);
//	}
//}

//ex 41-2) this 용법2-2
//class Tiger {
//	Tiger f1() {
//		System.out.println("아침먹고");
//		return this;
//	}
//	Tiger f2() {
//		System.out.println("점심먹고");
//		return this;
//	}
//	Tiger f3() {
//		System.out.println("저녁먹고");
//		return this;
//	}
//}
//public class Hello {
//	public static void main(String[] args) {
//		Tiger t = new Tiger();
//		// 체이닝 기법을 사용하는 이유는 코드의 난입을 막는 목적
//		t.f1().f2().f3();
//		
//		// 한 세트 개념이 아니다
//		t.f1();
//		t.f2();
//		t.f3();
//		
//		// 중간에 연관이 없는 코드가 난입했다
//		t.f1();
//		System.out.println("잔다.");
//		t.f2();
//		t.f3();
//	}
//}

//ex41-2) this 용법2-1
//함수 호출 체이닝을 위해서 사용된다
//class Tiger {
//	Tiger f1() {
//		System.out.println(this.hashCode());
//		return this;
//	}
//	Tiger f2() {
//		System.out.println("f2 call");
//		return this;
//	}
//	void f3() {
//		System.out.println("f3 call");
//	}
//}
//public class Hello {
//	public static void main(String[] args) {
//		Tiger t = new Tiger();
//		System.out.println(t.hashCode());
//		Tiger t2 = t.f1();
//		System.out.println(t2.hashCode());
//		System.out.println("-------------------------------------------------");
//		
//		Tiger tiger = new Tiger();
//		// chaining 기법
//		tiger.f1().f1().f1().f2().f2().f2().f2().f2().f2().f3();;
//	}
//}

//ex41-1) this 용법1
//생성자 함수의 인수명과 필드명을 구분하기 위하여 사용한다
//class Tiger {
//	String name;
//	int age;
//
//	Tiger() {
//	}
//	Tiger(String name, int age) {
//		this.name = name;
//		this.age = age;
//	}
//	@Override
//	public String toString() {
//		return "Tiger [name=" + name + ", age=" + age + "]";
//	}
//}
//public class Hello {
//	public static void main(String[] args) {
//		Tiger t = new Tiger("홍길동", 20);
//		System.out.println(t.toString());
//	}
//}

/*
//ex40) this 정의
//this : new를 이용해서 생성된 객체를 공유하는 변수 
class Tiger {
	int num = 10;
	Tiger() {
		// this = t; 공유가 되었다
		System.out.println(this.hashCode());
	
		//this.num = 20;
		num = 20;
	}
	
	void f1() {
	}
	void f2() {
		this.f2();
	}
}

public class Hello {
	public static void main(String[] args) {
		Tiger t = new Tiger();
		System.out.println(t.hashCode());
		t.num = 20;
		
		// 참조 변수 t,t2가 가르키는 객체가 다르다
		Tiger t2 = new Tiger();
	}
}
*/

//ex39) this 예시
//class Tiger {
//	String name;
//	int age;
//	
//	Tiger() {
//	}
//	Tiger(String name, int age) {
//		this.name = name;
//		this.age = age;
//	}
//	
//	@Override
//	public String toString() {
//		return "Tiger [name=" + name + ", age=" + age + "]";
//	}
//}
//
//public class Hello {
//	public static void main(String[] args) {
//		Tiger t = new Tiger("호랑이", 10);
//		System.out.println(t.toString());
//	}
//}

//ex 38) 인수전달 생성자
//class Tiger {
//	String name;
//	int age;
//
//	Tiger() {
//		name = "홍길동";
//		age = 20;
//	}
//
//	Tiger(String n, int a) {
//		name = n;
//		age = a;
//	}
//
//	void showData() {
//		System.out.println(name + " " + age);
//	}
//
//	@Override
//	public String toString() {
//		return "Tiger [name=" + name + ", age=" + age + "]";
//	}
//}
//
//public class Hello {
//	public static void main(String[] args) {
//		Tiger t1 = new Tiger();
//		t1.showData();
//		System.out.println(t1.toString());
//
//		// 인수 전달 생성자를 만들지 않으면 생성되는 모든 객체는 같은 값을 가진다
//		Tiger t2 = new Tiger();
//		t2.showData();
//
//		Tiger t3 = new Tiger("호랑이", 40);
//		t3.showData();
//	}
//}

//ex37) 기본생성자 
////class Tiger {
////	
////}
////class Tiger {
////	Tiger() {
////	}
////}
////위 두 코드는 동일한 코드이다
////생성자가 없으면 기본 생성자를 자동으로 만들어 준다
////만약 생성자를 만들게 된다면 기본 생성자를 만들지 않는다
//class Tiger {
//	Tiger() {
//	}
//	Tiger(int num) {
//	}
//}
//
//public class Hello {
//	public static void main(String[] args) {
//		// 객체는 생성될 때 무조건 생성자를 호출한다
////		Tiger t = new Tiger();
////		System.out.println(1);
//
//		// 기본 생성자가 없기 때문에 에러가 발생한다
//		// 그래서 원칙적으로 기본 생성자를 그냥 만들어준다
//		Tiger t = new Tiger();
//		System.out.println(1);
//	}
//}

//ex36 클래스 - 생성자 
//class Tiger {
//	// 1. 생성자 : 생성자 함수
//	// 2. 생성자도 함수이기 때문에 오버로딩이 가능
//	// 3. 함수이름이 반드시 클래스 이름과 동일해야 한다
//	// 4. 인수전달을 할 수 있지만 리턴값을 가질 수 없다
//	// 5. 목적은 멤버변수초기화가 유일한 목적
//	// 6. 객체가 생성(new)될 때 자동 호출이 되고 임의로 호출할 수 없다
//	
//	// 기본 생성자
//	Tiger() { 
//		System.out.println("생성자 콜1");
//	}
//	Tiger(int num) {
//		System.out.println("생성자 콜2");
//	}
//	void f1() {
//		System.out.println("f1 call");
//	}
//	void f2() {
//		// 스스로 자신의 클래스 타입으로 객체를 만들 수 있는가 ? YES
//		Tiger t = new Tiger();
//		// 사용하는 주체가 다르다
//		t.f1();
//		f1();
//	}
//}
//
//public class Hello {
//	public static void main(String[] args) {
//		System.out.println(1);
//		Tiger t = new Tiger();
//		System.out.println(2);
//		Tiger t2 = new Tiger(100);
//		System.out.println(3);
//	}
//}

////ex35) main 메서드
//public class Hello {
//	// 생성자를 가질 수 있다
//	// 필드를 가질 수 있다
//	// 메서드를 가질 수 있다
//	int count = 100;
//	void f1() {
//		
//	}
//	void f2() {
//		System.out.println(count);
//		f1();
//	}
//	static void f3() {
//		System.out.println("f3");
//	}
//	
//	// main()에 static이 없으면 따로 Hello 객체를 생성해야 한다
//	public static void main(String[] args) {
//		// static 안에서는 static만 사용할 수 있다
////		System.out.println(count); 
////		f1();
//		f3();
//		Hello h = new Hello();
//		h.f1();
//		h.f3();
//		
//	}
//}


/*
//ex34) static : 정적(고정)!= 동적(dynamic)
//static은 처음부터 메모리에 존재한다 (객체를 생성해서 사용할 필요가 없다)
//static은 속도와 연관 (객체를 생성하는 데 오랜 시간이 소요되기 때문)
class Tiger {
	static int count;
	
	static void f1() {
		System.out.println("call 1");
	}
	
	void f2() {
		System.out.println("call 2");
	}
	
	void f3() {
		f2(); // 인스턴스 메서드는 인스턴스 메서드를 호출할 수 있다
		System.out.println("call 3");
	}
	
	static void f4() {
		// static 메서드 안에서는 static 멤버만 사용할 수 있다
		// f2(); // static 메서드는 인스턴스 메서드를 호출할 수 없다 (객체가 생성됬는지 모르기 때문)
		f1();
	}
}
public class Hello {
	public static void main(String[] args) {
		Tiger.f1();
		Tiger t = new Tiger();
		t.f2(); // 인스턴스 메서드는 객체를 생성한 이후 사용할 수 있다
		t.f1(); // 객체를 생성해서 static메서드도 사용할수는 있다
		
		// abs() 역시 static 메서드(정수 절댓값 계산)
		System.out.println(Math.abs(-100));
		// 객체를 생성할 수 없는 이유는 Math클래스의 생성자가 private로 되어있기 때문이다
		// Math m = new Math();
		System.out.println(Math.PI);
		System.out.println("----------------------------------------------------------");
		t.f3();
	}
}
*/


//ex33) 오버로딩
//class Tiger {
//	// 오버로딩 규칙
//	// 1. 전달되는 인수의 개수가 다를 때
//	// 2. 인수의 개수가 같더라도 인수타입이 다를 때
//	void show() {
//		System.out.println(1);
//	}
//
//	void show(int num) {
//		System.out.println(2);
//	}
//
//	void show(int a, int b) {
//		System.out.println(3);
//	}
//
//	void show(short num) {
//		System.out.println(4);
//	}
//}
//
//class Point {
//	int x, y;
//}
//class Rect {
//	// int width, heigh;
//	int getArea(int w, int h) {
//		return w * h;
//	}
//	int getArea(Point s, Point e) {
//		int w = e.x - s.x;
//		int h = e.y - s.y;
//		return w * h;
//	}
//	int getArea(int x1, int y1, int x2, int y2) {
//		int w = x2 - x1;
//		int h = y2 - y1;
//		return w * h;
//	}
//}
//public class Hello {
//	public static void main(String[] args) {
//		Tiger t = new Tiger();
//		t.show();
//		t.show((int) 1);
//		t.show(2, 3);
//		t.show((short) 4);
//		Rect r = new Rect();
//		System.out.println(r.getArea(3, 4));
//		System.out.println(r.getArea(3, 4, 6, 8));
//		Point p1 = new Point();
//		Point p2 = new Point();
//		p1.x = 3; 
//		p1.y = 4; 
//		p2.x = 8; 
//		p2.y = 9; 
//		
//		System.out.println(r.getArea(p1, p2));
//	}
//}
////////////////////////////////////////////////


/*
//ex32)
class Lion{
	void cry() {
		System.out.println("어흥");
	}
}
class Tiger{
	String f1() {
		//String 타입의 클래스 객체가 리턴된다.
		return "호랑이";
	}
	Lion f2() {
		Lion lion = new Lion();
		return lion; // lion >> 확보받은 메모리
	} // Lion형으로 return
}
public class Hello {
	public static void main(String[] args) {
		Tiger t = new Tiger();
		System.out.println(t.f1());
		Lion l = t.f2(); // 공유되었다.
		l.cry();
	}
}
*/

/*
//ex31)
class Lion{
	void cry() {
		System.out.println("어흥");
	}
}
class Tiger {
	// int a = 10, String b = "호랑이", ch = '책'
	// String으로 인수 전달 받았다는 것은 클래스로 전달 받았다.
	void func(int a, String b, char ch, Lion lion) {
		System.out.println(a + b + ch);
		System.out.println("2 : " + lion.hashCode()); // 동일한 객체
		lion.cry();
	}
}
public class Hello {
	public static void main(String[] args) {
		Tiger t = new Tiger();
		Lion l = new Lion();
		System.out.println("1 : " + l.hashCode());
		t.func(10, "호랑이", '책', l);
	}
}
*/


/*
//ex30)
class Tiger{
	int func() {
		return 100;
	}
	void test() {
		
	}
}
public class Hello {
	public static void main(String[] args) {
		Tiger t = new Tiger();
		
		// 1. 버린다.
		t.func();
		
		// 2. 변수로 받아서 사용
		int num=t.func();
		System.out.println(num*10);
		
		// 3. 바로 출력으로 연결.
		System.out.println(t.func());
		
		// 출력으로 연결시킬수없다.
//		System.out.println(t.test());
	}
}
*/

/*
//ex29)
class Tiger{
	// void f1()만 함수 원형(prototype)
	//1
	void f1() {
		System.out.println(1);
	}
	//2
	void f2(int a) { // 인수 전달은 1개 이상 할 수 있다.
		System.out.println(2);
	}
	//3
	int f3() { // 리턴은 1개만 할 수 있다.
		System.out.println(3);
		return 0;
	}
	//4
	int f4(int a) {
		System.out.println(4);
		return 0;
	}
}
public class Hello {
	public static void main(String[] args) {
		Tiger t = new Tiger();
		t.f1();
		t.f2(10);
		t.f3();
		t.f4(0);
	}
}
*/


/*
//ex28)
class Person {
	// 필드는 외부에 오픈시키지 않는다.
	// 데이터 은닉
	private String name="홍길동";
	private int age=20;
	
	public void setName(String n) {
		this.name=n;
	}
	public int getAge() {
		return age;
	}
	public String getName() {
		return name;
	}
	
}
public class Hello {
	public static void main(String[] args) {
		Person p1=new Person();
		p1.setName("강길동");
		System.out.println(p1.getName());
		
		// 이렇게 쓰면 안된다.
		//p1.name="강길동";
		//p1.age=30;
		//System.out.println(p1.name + " " + p1.age);
	}
}
*/


/*
//ex27)
class Tiger{
	int num;
	float count;
	String str;
}
public class Hello {
	public static void main(String[] args) {
		Tiger t1 = new Tiger();
		Tiger t2 = new Tiger();
		t1.num=10;
		t1.count=20.0f;
		t1.str="호랑이1";
		System.out.println(t1.num);
		
		t2.num=30;
		t2.count=40.0f;
		t2.str="호랑이2";
		System.out.println(t2.num);
	}
}
*/



/*
//ex26) 클래스
//클래스의 3대요소 : 생성자, 필드, 메소드
//GOF의 디자인 패턴
// 1. 파일 1개당 클래스 1개가 원칙이다.
// 2. 파일명은 클래스명과 동일하게 하는게 원칙이다.
// 3. 클래스명의 첫자는 대문자, 파일명의 첫자는 소문자
// 4. 1개의 파일에 여러개의 클래스가 들어갈 수 있는데
// 		반드시 1개만 public 이어야 한다.
// 5. Person 설계도이다.
//	1. 생성자
//	2. 필드(field) >> 변수
//	3. method     >> 함수(function)
// 6. 객체 생성 방법
// Person person = new Person();
class Person{
	
}
public class Hello {
	public static void main(String[] args) {
		// new는 메모리를 사용하는 것이다.
		Person p1 = new Person();
		Person p2 = new Person();
		Person p3 = new Person();
		System.out.println(p1.hashCode());
		System.out.println(p2.hashCode());
		System.out.println(p3.hashCode());
		
		//서로 다른 이름으로 객체를 공유했다.
		//서로 다른 이름으로 객체를 참조(reference)했다.
		//사회 : 홍길동, 집 : 곰돌이
		Person p4=p1;
		System.out.println(p4.hashCode());
		
		// 메모리 반납코드가 있어야 하는 것이 원칙인데
		// 자바는 사용하지 않는다고 판단이 되면 자동 반납이다.
		// 자바가 메모리를 가비지 콜렉션을 한다.
		
	}
}
*/
// 2022.10.26







/*
//ex25) random 세로 더하기
import java.util.Random;
public class Hello {
	public static void main(String[] args) {
		Random rn = new Random();
		int[][] arr = new int[3][4];
		int[] sum = new int[4];
		
		for (int i = 0; i < 3; i++) {
			for (int j = 0; j < 4; j++) {
				arr[i][j] = rn.nextInt(10);
			}
		}
		// 원본 출력
		for (int i = 0; i < 3; i++) {
			for (int j = 0; j < 4; j++) {
				System.out.print(arr[i][j] + " ");
			}System.out.println();
		}
		
		// 덧셈하고 출력
		for (int j = 0; j < 4; j++) {
			for (int i = 0; i < 3; i++) {
				sum[j] += arr[i][j];
			}
			System.out.print(sum[j] + " ");
		}
	}
}
*/


/*
//ex24) random
import java.util.Random;
public class Hello {
	public static void main(String[] args) {
		Random rn = new Random();
		for (int i = 0; i < 10; i++) {
			// ex1)
			// +- 20억 사이의 숫자를 랜덤하게 얻는다.
			// int num = rn.nextInt();
			// System.out.println(num);
			
			// ex2)
			// 0~9
			// 0 <= x < 10
			System.out.print(rn.nextInt(10) + " ");
		}System.out.println();
		for (int i = 0; i < 10; i++) {
			System.out.print(new Random().nextInt(100) + " ");
		}System.out.println();
		System.out.println();
		
		for (int i = 0; i < 3; i++) {
			for (int j = 0; j < 4; j++) {
				int num = rn.nextInt(10);
				System.out.print(rn.nextInt(10) + " ");
			}System.out.println();
		}
	}
}
*/



/*
//ex23)
public class Hello {
	public static void main(String[] args) {
		int[] arr = new int[3];
		int[][] brr = new int[5][3]; // [세로길이][가로길이]
		int[][][] crr = new int[2][5][3]; // [세로길이][가로길이]
		System.out.println("test1 : " + brr.length);
		System.out.println("test2 : " + brr[0].length);
		
		for (int i = 0; i < brr.length; i++) {
			for (int j = 0; j < brr[0].length; j++) {
				brr[i][j] = i*brr[0].length+j;
			}
		}
		
		for (int i = 0; i < 5; i++) {
			for (int j = 0; j < 3; j++) {
				System.out.printf("%3d", brr[i][j]);
			}System.out.println();
		}
	}
}
*/


/*
//ex22)
class Tiger{
	
}
public class Hello {
	public static void main(String[] args) {
//		String s2=new String("호랑이");
//		Tiger t1=new Tiger();
		
		String[] t1   =new String[3];
		Tiger[] t2    =new Tiger[3];
		
		String[] t31  =new String[] {new String("호"), new String("랑")};
		String[] t32  =new String[] {"호", "랑"};
		Tiger[] t4    =new Tiger[] {new Tiger(), new Tiger()};
		
		String[] t51  ={new String("호"), new String("랑")};
		String[] t52  ={"호", "랑"};
		Tiger[] t6    ={new Tiger(), new Tiger()};
		
		// 클래스 : String
		// 클래스
		// 객체지향프로그래밍
	}
}
*/





/*
//ex21)
class Tiger {
	void f1() {
		System.out.println("call");
	}
}
public class Hello {
	public static void main(String[] args) {
		Tiger[] arr = new Tiger[3];
		for (int i = 0; i < arr.length; i++) {
			arr[i] = new Tiger();
		}
		
		for (int i = 0; i < arr.length; i++) {
			arr[i].f1();
		}
		
		Tiger[] brr=new Tiger[] {
				new Tiger(), 
				new Tiger(), 
				new Tiger()
		};
		for (Tiger obj : brr) {
			obj.f1();
		}
		Tiger[] crr=new Tiger[] {
				new Tiger(), 
				new Tiger(), 
				new Tiger()
		};
	}

}
*/




/*
//ex20)
public class Hello {
	public static void main(String[] args) {
		String[] arr=new String[4];
		
		arr[0]=new String("앵무새0");
		arr[0]="앵무새0";
		
		arr[1]="앵무새1";
		arr[2]="앵무새2";
		arr[3]="앵무새3";
		String[] brr=new String[] {
			new String("호랑이"), 
			"코끼리", 
			"독수리"};
		String[] crr={"호랑이1", "코끼리1", "독수리1"};
		System.out.println(arr[2]);
		for (int i = 0; i < brr.length; i++) {
			System.out.print(brr[i] + " ");
		}System.out.println();
		for (String value : crr) {
			System.out.print(value + " ");
		}System.out.println();
	}
}
*/


/*
//ex19) 배열
public class Hello {
	public static void main(String[] args) {
		int a=10; //일반변수
		
		// array
		// 방법1
		int[] arr=new int[5];
		// 방법2
		int[] brr=new int[] {1,2,3,4};
		// 방법3
		int[] crr= {1,2,3,4,5,6};
		System.out.println(arr.length);
		System.out.println(brr.length);
		System.out.println(crr.length);
		
		for(int i=0;i<brr.length;i++) {
			System.out.print(brr[i] + " ");
		}System.out.println();
		
		// i, value, item, x
		// foreach
		for (int value : crr) {
			System.out.print(value + " ");
		}System.out.println();
		
		//
		int[] drr=new int[5];
		// 0~4
		// ArrayIndexOutOfBoundsException
		// drr[5] = 100;
		drr[2] = 100;
		drr[2*5-7] = 100;
		drr[4] = 2;
		drr[drr[4]*3-5] = 999;
	}
}
*/


/*
//ex18) 우박수 문제
public class Hello {
	public static void main(String[] args) {
		int num=1234567;
		while(true) {
			System.out.println(num);
			if(num%2==0) {
				num=num/2;
			}else {
				num=num*3+1;
			}
			
			if(num==1) {
				System.out.println(num);
				break;
			}
		}
	}
}
*/


/*
//ex17)
// for : 정확하게 반복횟수를 알고 있을 때
// while : 프로그래머가 반복횟수를 모를때...
public class Hello {
	public static void main(String[] args) {
		int num=0;
		// ex1)
		while(num<4) {
			System.out.println(num++);
		}
		// ex2)
		while(true) {
			System.out.println(num++);
			if(num==33) {
				System.out.println("탈출 일보직전");
				break;
			}
		}
	}
}
*/

/*
//ex16)
public class Hello {
	public static void main(String[] args) {
		//1. case 뒤에는 변수가 올 수 없다.
		//2. switch에는 변수를 사용할 수 있다.
		//3. case뒤에 숫자가 중복될 수 없다.
		//4. 자바 버전에 따라서 문자열/문자를 분기시킬 수 있다.
		//5. 일반적으로 case break는 한쌍인데 의도적으로 break를 생략할 수 있다.
		int num=200;
		String s="독수리";
		
		switch (s) {
		
		case "독수리":
			System.out.println(1);
			break;
		case "코끼리":
			System.out.println(1);
			break;
			
		default: break;
		}
		
		switch (s) {
		case "독수리": //break;
		case "코끼리":
			System.out.println("동물입니다.");
			break;
		case "소나무": //break;
		case "대나무":
			System.out.println("식물입니다.");
			break;
			
		default: break;
		}
		
		int jumsu=80;
		switch(jumsu/10) {
		case 10: //break;
		case 9:
			System.out.println("A");
			break;
		case 8:
			System.out.println("B");
			break;
		default:
			break;
		}
	}
}
*/



//ex15) for in for
//public class Hello {
//	public static void main(String[] args) {
//		// ex1)
//		// 격자형태(테이블형태, 맵형태)
//		for(int i=0;i<3;i++) {
//			for (int j = 0; j < 4; j++) {
//				System.out.print("[" + i + " " + j + "]");
//			}
//			System.out.println();
//		}System.out.println();
//		
//		// ex2)
//		// 격자형태(테이블형태, 맵형태)
//		for(int i=0;i<3;i++) {
//			for (int j = 0; j < 4; j++) {
//				System.out.print(" * ");
//			}
//			System.out.println();
//		}System.out.println();
//		
//		// ex3)
//		int width=4, height=3;
//		for(int i=0;i<height;i++) {
//			for (int j = 0; j < width; j++) {
////				System.out.print(i*width+j);
//				System.out.printf("%2d", i*width+j);
//			}
//			System.out.println();
//		}System.out.println();
//		
//		System.out.printf( "호랑이\n" );
//		System.out.printf( "코끼리\n" );
//		System.out.printf( "코%d끼%d리%d\n", 777, 888, 999 );
//		System.out.printf("%d\n", 3);
//		System.out.printf("%4d\n", 3);
//		System.out.printf("%04d\n", 3);
//		
//		int a=10, b=20, c=30;
//		String s = String.format("무궁화:%d 소나무:%d 백합:%d", 10, 20, 30);
//		System.out.println("output : " + s);
//		
//		//ex4)
//		for(int i=0;i<3;i++)
//			for(int j=0;j<4;j++)
//				System.out.println("test");
//		
//		//ex5)
//		for(int i=0;i<3;i++) {
//			for(int j=0;j<4;j++)
//				System.out.println("apple");
//			
//			System.out.println("banana");
//		}
//		
//		//ex6)
//		//for(int i=0;i<3;i++);
//		int count;
//		for(count=0; count<3; count++);
//		
//		System.out.println(count);
//	}
//}


//ex14)
//public class Hello {
//	// int a = n1++;
//	// int b = ++n2;
//	static void f1(int a, int b) {
//		System.out.println(a + " " + b);
//	}
//	public static void main(String[] args) {
//		int a = 3;
//		int b = a++; //1. 대입 2. 증가
//		System.out.println(a + " " + b);
//		
//		int c = 3;
//		int d = ++c; //1. 증가 2. 대입
//		System.out.println(c + " " + d);
//		int n1=3, n2=3;
//		System.out.println("-------------------------");
//		f1(n1++, ++n2);
//		n1++;
//		++n2;
//		// 자료가 10이 있을때
//		// 이 자료를 순회하면서 하나씩 가져오거나 저장할때
//		// 일반적으로 이터레이터를 사용하게 되는데
//		// 이터레이터 연산 중에서
//		// 이터레이터++
//		// ++이터레이터
//		// 라는 두 명령이 존재한다.
//		// 이때 두 명령의 실행속도는 30배정도 차이가 난다.
//		// ++이터레이터가 30배정도 빠르다.
//		// 그래서
//	}
//}

//ex13)
//public class Hello {
//	public static void main(String[] args) {
//		// 1만 증가 시킨다는 전제 아래에서
//		int num=0;
//		//대입연산과 덧셈연산이 사용된다.
//		// move, add 어셈블리어로 번역
//		num=num+1;
//		System.out.println(num);
//		// inc
//		// num++, ++num은 속도가 똑같다.
//		num++;
//		System.out.println(num);
//		++num;
//		System.out.println(num);
//		
//		num+=1; // 약간 좋다.
//		System.out.println(num);
//		
//		int test=10;
//		int count=20;
//		test+=count;
//		// test = test + count;
//	}
//}


//ex12)
//public class Hello {
//	public static void main(String[] args) {
//		char ch = 'A'; //문자 'A'의 아스키코드값은 65
//		// println ch가 무슨 타입인지 확인한다.
//		// 문자타입이라고 확인하고 숫자를 아스키문자로 출력한것이다.
//		System.out.println(ch);
//		// 강제 형 변환(단, 현재 라인에서만 적용된다.)
//		// 강제 형 변환(타입캐스팅)
//		System.out.println((int)ch);
//		System.out.println(65);
//		System.out.println((char)65);
//		int num = 65;
//		System.out.println(num);
//		System.out.println((char)num);
//		System.out.println("-------------------------");
//		
//		char ch2='A';
//		for(int i=0;i<26;i++) {
//			System.out.println((char)(ch2+i));
//		}
//	}
//}


//ex11)
//public class Hello {
//	public static void main(String[] args) {
//		// 기본코드1
//		int num=5;
//		for(int i=0;i<10;i++) {
//			System.out.println(num+ " * " + i + " = " + num*i);
//		}
//		// 기본코드2
//		int sum=0;
//		num = 10;
//		for (int i = 0; i <= num; i++) {
//			//sum = sum + i;
//			sum+=i; // 복합대입연산자
//		}
//		System.out.println(sum);
//		
//	}
//}



// ex10) for
//public class Hello {
//	public static void main(String[] args) {
//		// 정석코드1
//		for (int i = 0; i < 4; i++) {
//			System.out.println(i);
//		}
//		// 정석코드2
//		for (int i = 1; i <= 4; i++) {
//			System.out.println(i);
//		}
//		// 정석코드3
//		// 4*2+1번
//		int aa=4;
//		for (int i = -aa; i <= aa; i++) {
//			System.out.println(i);
//		}
//		// bad code
//		for(int i=0;i<=4;i++) {
//			System.out.println(i);
//		}
//		for(int i=2;i<=4;i++) {
//			System.out.println(i);
//		}
//		for(int i=2;i<=4;i+=2) {
//			System.out.println(i);
//		}
//		for(int i=2;i>4;i+=2) {
//			System.out.println(i);
//		}
//	}
//}



// ex9) if
//public class Hello {
//	public static void main(String[] args) {
//		// if for while switch
//		
//		// ex1)
//		// if(true)
//		// if(3>2)
//		// if(true||false)
//		if(true) {
//			System.out.println(1);
//			System.out.println(2);
//		}
//		// scope 생략 가능
//		if(true)
//			System.out.println(3);
//		
//		// ex2)
//		int num=10;
//		if(num%2==0) {
//			System.out.println("짝수");
//		}else {
//			System.out.println("홀수");
//		}
//		
//		// ex3) n개중에 1개를 선택
//		if(false) {
//			System.out.println(10);
//		}else if(false) {
//			System.out.println(20);
//		}else if(true) {
//			System.out.println(30);
//		}else {
//			System.out.println(40);
//		}
//		
//		// ex4)
//		if(true) {
//			if(false) {
//				if(true) {
//					
//				}
//			}else {
//				if(true) {
//					
//				}else if(false) {
//					
//				}else {
//					
//				}
//			}
//		}
//	}
//}


// ex8) 논리연산(관계연산)
//public class Hello {
//	public static void main(String[] args) {
//		// and(&&), or(||), not(부정)
//		System.out.println(false && false);
//		System.out.println(false && true);
//		System.out.println(true && false);
//		System.out.println(true && true);
//		System.out.println("------------------");
//		System.out.println(false || false);
//		System.out.println(false || true);
//		System.out.println(true || false);
//		System.out.println(true || true);
//		System.out.println("------------------");
//		boolean test=true;
//		System.out.println(!test);
//		System.out.println(!(10>20));
//		
//		System.out.println( true && true && true && false );
//		System.out.println( !(false && true && false && false) );
//		
//		// 연산자 우선순위 : 산술 > 관계(비교) > 논리
//		System.out.println(
////			3+2>2 && 4-2<10 && 3*3>=8
////			5>2 && 2<10 && 9>=8
////			true && true && true
//				);
//		// 아래 프로그램은 잘못 작성된 예이다.
//		// 코드의 가독성이 떨어진다.
//		// System.out.println(true && true || true);
//		// 연산자 우선순위를 결정해서 적어주는 것이 좋다.
//		System.out.println((true && true) || true);
//		System.out.println(true && (true || true));
//		
//		
//	}
//}


//ex7) 비교연산(관계연산)
//public class Hello {
//	public static void main(String[] args) {
//		// 산술연산
//		System.out.println(3>2);
//		System.out.println(3<2);
//		System.out.println(3>=2);
//		System.out.println(3<=2);
//		System.out.println(3==2);
//		System.out.println(3!=2);
//		
//		
//	}
//}



// ex6) 산술연산/문자열 연결
//public class Hello {
//	public static void main(String[] args) {
//		System.out.println(27 + 4);
//		System.out.println(27 - 4);
//		System.out.println(27 * 4);
//		System.out.println(27 / 4); //몫
//		// result : 0 ~ 3
//		System.out.println(27 % 4); //나머지
//		
//		System.out.println(27+4);
//		// 왼쪽에서 오른쪽으로 해석한다.
//		// 숫자 + 문자열 = 문자열
//		// 문자열 + 숫자 = 문자열
//		// 문자열 + 문자열 = 문자열
//		System.out.println(27+"호랑이");
//		System.out.println("호랑이"+27);
//		System.out.println("호랑이" + "코끼리");
//		System.out.println(27+13+"호랑이");
//		System.out.println(40+"호랑이");
//		System.out.println("호랑이" + 27 + 13);
//		System.out.println(27 + "호랑이" + 13);
//		System.out.print(27 + " " + 13);
//		int a = 10, b = 20;
//		System.out.println(a + " " + b);
//		// 문자 : 1개
//		// 문자열 : 0개이상
//	}
//}
//


// ex5) 표기법 정리
//public class Hello {
//	public static void main(String[] args) {
//		// 카멜표기법
//		int appleNum = 10;
//		// 파스칼표기법 : 맨앞에 오는 글자 대문자로 표기 + 카멜표기법
//		int TotalNumber = 10;
//		// 헝가리안표기법 : 접두어에 자료형을 알아볼 수 있게 표기
//		String strName;
//		// 스네이크 표기법 : 단어 사이에 언더바를 넣어서 표기
//		int total_number;
//	}
//}


// ex4)
//public class Hello {
//	public static void main(String[] args) {
//		short a = 200;
//		System.out.println(Short.MAX_VALUE);
//		System.out.println(Short.MIN_VALUE);
//		System.out.println(Long.MAX_VALUE);
//		System.out.println(Long.MIN_VALUE);
//		System.out.println(Integer.MAX_VALUE);
//		System.out.println(Integer.MIN_VALUE);
//		System.out.println(Character.MAX_VALUE);
//		System.out.println(Character.MIN_VALUE);
//		
//		int b = 10;
//		if (b < Short.MAX_VALUE) {
//			
//		}
//	}
//}

// ex03)
//public class Hello {
//	public static void main(String[] args) {
//		// type(형) int
//		// >> int, double, float, short, long, char, boolean, byte
//		// 8가지
//		// byte(1) : +- 127
//		// short(2) : +- 3xxxx
//		// char(2) : 문자 전용(0~65535)
//		// int(4) : 정수 전용 2^32(+- 20억)
//		// long(8) : 8byte 정수
//		// float(4) : 실수 전용(3.14)
//		// double(8) : 8byte 실수
//		// boolean(1) : true/false
//		
//		int a = 10;
//		double sum = 0.0;
//		for (int i=0;i<100;i++) {
//			sum+=0.1f;
//		}
//		System.out.println(sum);
//		
//	}
//}
// 2022.10.25

// ex1) 환경설정
// ex2) 
//public class Hello {
//	public static void main(String[] args) {
//		System.out.println("호랑이1");
//		System.out.println("호랑이2");
//		System.out.println("호랑이3");
//		System.out.println("호랑이4");	
//	}
//}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-28 14:18:17.617
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-28 14:18:17.618
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-28 14:18:18.744
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package Pack01;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.Random;
import java.util.Scanner;

// ex)
//public class Hello {
//	public static void main(String[] args) {
//		
//	}
//}


//ex65)
public class Hello {
	static String hexaToBinary(int n) {
		String result = Integer.toBinaryString(n);
		
		while(result.length() < 32) {
			result = "0" + result;
		}
		StringBuffer result1 = new StringBuffer(result);
		for (int i = 0; i < 7; i++) {
			result1.insert((7-i)*4, " ");
		}
		return result1.toString();
	}
	
	public static void main(String[] args) {
		// ARGB
		int num = 0x3b12cd59;
		//        0x3b12cd59; A
		//      & 0x00ff0000; M
		//        0x00120000; R
		//  >> 16 0x00000012;
		System.out.println(hexaToBinary(num));
		System.out.println(hexaToBinary(0x00ff0000));
		System.out.println(hexaToBinary(num & 0x00ff0000));
		System.out.println(hexaToBinary((num & 0x00ff0000) >> 16));
		int Red = (num & 0x00ff0000) >> 16;
		System.out.println(Red);
		
		int Green = (num & 0x0000ff00) >> 8;
		System.out.println(Green);
		
		int Blue = (num & 0x000000ff);
		System.out.println(Blue);
		
		(Red << 16) || (Green << 8) || Blue
	}
}



/*
//ex64) 비트 연산
public class Hello {
	static String hexaToBinary(int n) {
		String result = Integer.toBinaryString(n); //111011000100101100110101011001
		//System.out.println("1 : " + result.length());
		
		while(result.length() < 32) {
			result = "0" + result;
		}
		//System.out.println("2 : " + result);
		
		StringBuffer result1 = new StringBuffer(result); // StringBuffer는 갱신을 할수있다
		//System.out.println("3 : " + result1);
		
		for (int i = 0; i < 7; i++) {
			result1.insert((7-i)*4, " ");
		}
		//System.out.println("4 : " + result1); //0011 1011 0001 0010 1100 1101 0101 1001
		return result1.toString(); //StringBuffer를 String으로 변환해준다(return값이 String이므로)
	}
	
	public static void main(String[] args) {
		// 앞에 0x가 붙으면 뒤에는 16진수가 된다 / 0만 붙으면 뒤에는 8진수가 된다
		// 진법 : 2진법, 10진법, 16진법(개인적으로 익히기)
		// 16진법 : 0 1 2 3 4 5 6 7 8 9 A  B  C  D  E  F
		//                           10 11 12 13 14 15
		int num = 0x3b12cd59; //16진수를 2진수로 바꿔보자!
		// 이진수 : 11 1011 0001 0010 1100 1101 0101 1001
		// 끝에서부터 4자리씩 끊고 앞에 공백에 0채워넣기
		// 0011 1011 0001 0010 1100 1101 0101 1001
		String result = Integer.toBinaryString(num); //111011000100101100110101011001
		System.out.println(result);
		
		//직접 함수 만들어서 네자리씩 끊기
		System.out.println(hexaToBinary(num));
	}
}
*/


/*
//ex63-2) 제네릭 문법
// class 개수를 줄이는 건 아님(class는 사용할때마다 내부적으로 생성된다) - 보이는 코드길이만 줄어듦
class Tiger<T>{
	private T data;
	
	public T getData() {
		return data;
	}
	public void setData(T data) {
		this.data=data;
	}
}
public class Hello {
	public static void main(String[] args) {
		// Tiger<Integer> t = new Tiger<Integer>();
		Tiger<Integer> t1 = new Tiger<>();
		t1.setData(100);
		System.out.println(t1.getData());
		
		
		Tiger<String> t2 = new Tiger<>();
		t2.setData("호랑이");
		System.out.println(t2.getData());
		
		
		Tiger<Float> t3 = new Tiger<>();
		t3.setData(3.14f);
		System.out.println(t3.getData());
		
		LinkedList<String> mm = new LinkedList<>();
		
	}
}
*/


/*
//ex63-1) 제네릭이 필요한 이유를 설명한 코드
class Tiger{
	private int data;
	
	public int getData() {
		return data;
	}
	public void setData(int data) {
		this.data=data;
	}
}
class Lion{
	private String data;
	
	public String getData() {
		return data;
	}
	public void setData(String data) {
		this.data=data;
	}
}
public class Hello {
	public static void main(String[] args) {
		Tiger t = new Tiger();
		t.setData(100);
		System.out.println(t.getData());
		
		Lion l = new Lion();
		l.setData("호랑이");
		System.out.println(l.getData());
	}
}
*/



/*
//ex62) annotation(@)
class A{
	void showMeTheMoney() {
		
	}
}

class B extends A{
	// @Override를 붙이는 이유(annotation)
	// : 이렇게 오타를 발생시키고 override를 하면 오류발생을 알려줌
//	@Override
//	void ShowMeTheMoney() {
//		System.out.println(2);
//	}
}

interface C{
	void f1();
}
class D implements C{
	// 코드 자동 완성을 이용하였다.(ctrl+space)
	@Override
	public void f1() {
		// TODO Auto-generated method stub
		
	}
}

public class Hello {
	public static void main(String[] args) {
		A a = new B();
		a.showMeTheMoney();
	}
}
*/


/*
//ex61) Collection
// CRUD(Create, Read, Update, Delete)에 맞게 알맞은 자료구조를 선택해서 사용해야함
// List(순서가 있음) - LinkedList, Stack, Vector, ArrayList
// Set(중복X) - HashSet, SortedSet-TreeSet
// Map(key:value) - Hashtable, HashMap, SortedMap-TreeMap

// LinkedList - 평균적으로 좋은 것, 추가, 삭제에 좋음, but 검색에 취약함
// 나머지는 각자 시간날때 해볼것!
// Queue Interface는 PriorityQueue, Deque, ArrayDeque

// Collection 중 LinkedList의 예시
public class Hello {
	public static void main(String[] args) {
		// <저장할 데이터 타입>
		// 반드시 클래스 타입만 가능하다.(LinkedList<int> 이런건 안됨)
		// LinkedList<Integer> mm = new LinkedList<Integer>();
		LinkedList<Integer> mm = new LinkedList<>();
		System.out.println(mm.size());
		
		// (Create)RUD
		mm.add(100);
		for (int i = 0; i < 10; i++) {
			mm.add(i*10+i);
		}
		System.out.println(mm.size() + "개 있다");
		
		// C(Read)UD
		// 방법1 : 활용성이 없다.(당장은 편하지만)
		System.out.println(mm);
		
		// 방법2 : 
		for (int i = 0; i < mm.size(); i++) {
			System.out.print(mm.get(i) + " ");
		}System.out.println();
		
		// 방법 : forEach :
		// i, data, x, value, item
		for (Integer value : mm) {
			System.out.print(value + " ");
		}System.out.println();
		
		int[] ar = {1, 2, 3};
		for (int value : ar) {
			System.out.print(value + " ");
		}System.out.println();
		
		System.out.println(mm.get(5));
		
		// CR(Update)D
		mm.set(5, 2022);
		System.out.println(mm);
		
		// CRU(Delete)
		mm.remove(4);
		System.out.println(mm);
		
		// C : create, insert, add
		// R : read, select, get
		// U : update, set
		// D : delete, remove, erase, clear
	}
}
*/
//2022.10.28


/*
//ex60) String
public class Hello {
	public static void main(String[] args) {
		String s = "무궁화꽃이피었습니다";
		
		// 1) 문자열 길이
		System.out.println(s.length()); //10
		
		// 2) 해당 인덱스의 문자
		System.out.println(s.charAt(3)); //꽃
		
		// 3) 해당 문자열의 시작인덱스(정확하게 일치하는 문자열이 포함되어있을때만)
		System.out.println(s.indexOf("궁화")); //1
		System.out.println(s.indexOf("나무")); //-1(포함X)
		if(s.indexOf("나무")==-1) {
			System.out.println("not found");
		}else {
			System.out.println("find");
		}
		
		// 4) 해당 문자열1을 해당 문자열2로 대체해서 출력함(단, 원본은 안바뀜)
		System.out.println(s.replace("꽃이", "나무가")); //무궁화나무가피었습니다
		System.out.println(s); //무궁화꽃이피었습니다
		String newString = s.replace("꽃이", "식물이");
		System.out.println(newString); //무궁화식물이피었습니다
		
		// 5) 해당 인덱스부터 끝까지 자른다(끝범위도 지정 가능)
		System.out.println(s.substring(3)); //꽃이피었습니다
		System.out.println(s.substring(3, 5)); //꽃이
		//(a, b) >> a부터 b-1까지
		
		
		// 그 외 String 클래스 메소드(실습)
		// 문자열에 이어붙이기(원본이 바뀌진 않음)
		System.out.println(s.concat("안녕")); //무궁화꽃이피었습니다안녕
		System.out.println(s); //무궁화꽃이피었습니다
		
		// 문자열에 해당 문자열이 포함되어있는지 true/false로 출력
		System.out.println(s.contains("궁")); //true
		System.out.println(s.contains("안")); //false
		
		// 문자열이 해당 문자열로 끝나는지 true/false로 출력
		System.out.println(s.endsWith("다")); //true
		System.out.println(s.endsWith(".")); //false
		
		// 문자열이 해당 문자열과 완전히 같은지 true/false로 출력
		System.out.println(s.equals("무궁화꽃이피었습니다")); //true
		System.out.println(s.equals("무궁화")); //false
		
		// 해당 문자열이 빈 문자열인지 true/false로 출력
		System.out.println(s.isEmpty()); //false
		System.out.println("".isEmpty()); //true
		
		// 문자열을 해당 문자열로 완전히 대체함(원본은 바뀌지 않음)
		System.out.println(s.replaceAll(s, "안녕")); //안녕
		System.out.println(s); //무궁화꽃이피었습니다
		
		// 문자열을 해당 문자열을 기준으로 나눠준다(원본은 바뀌지 않음)
		System.out.println(s.split("이")[0]); //무궁화꽃
		System.out.println(s.split("이")[1]); //피었습니다
		System.out.println(s); //무궁화꽃이피었습니다
		
		// 문자열을 소문자, 대문자로 바꿔준다(원본은 바뀌지 않음)
		String str = "aBcDefgH";
		System.out.println(str.toLowerCase()); //abcdefgh
		System.out.println(str.toUpperCase()); //ABCDEFGH
		System.out.println(str); //aBcDefgH
		
		// 문자열의 왼쪽, 오른쪽 공백을 제거해준다(가운데 공백들은 제거X)
		String str2 = " a b  c   d ";
		System.out.println(str2.trim()); //a b  c   d
	}
}
*/

/*
//ex59) Scanner(입력)
public class Hello {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.println("숫자를 입력하세요");
		int num = sc.nextInt();
		System.out.println("입력된 숫자는 : " + num + "입니다.");
	}
}
*/


/*
//ex58) Thread.sleep()
public class Hello {
	public static void main(String[] args) {
		System.out.println(1);
		
		for (int i = 0; i < 5; i++) {
			
			// 특정 조건 만족한 이후에 함수실행을 끝내는 이러한 함수를
			// 블로킹함수.
			try {Thread.sleep(3000);} catch (InterruptedException e) {}
			System.out.println(i*10);
		}
		
		System.out.println(2);
	}
}
*/


/*
//ex57)
class Tiger{
	void f1() {
		System.out.println(1);
		
		try {
			throw new Exception();			
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	// 이 함수를 호출한 게 Exception을 catch함
	void f2() throws Exception{
		System.out.println(2);
		throw new Exception();
	}
}
public class Hello {
	public static void main(String[] args) {
		Tiger t = new Tiger();
		t.f1();
		
		// Unhandled exception type Exception
		try {
			t.f2();			
		} catch (Exception e) {
			e.printStackTrace();
		}
		System.out.println("end");
	}
}
*/


/*
//ex56) 예외처리(exception)
public class Hello {
	public static void main(String[] args) {
		
		// 1. Arithmetic Exception
		try {
			System.out.println(4/0);
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		// 2. ArrayIndexOutOfBoundsException
		int[] ar = new int[3];
		try {
			ar[3] = 10;			
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		// 3. NullPointerException
		String str = null;
		try {
			System.out.println(str.length());			
		} catch (Exception e) {
			e.printStackTrace();
		}

		System.out.println("무궁화꽃이피었습니다.");
	}
}
*/


/*
//ex55) 삼항연산
public class Hello {
	public static void main(String[] args) {
		
		// ex1
		int num1;
		if(true) {
			num1 = 10;
		}else {
			num1 = 20;
		}
		
		num1 = true ? 10 : 20;
		
		// ex2
		if (true) {
			System.out.println("호랑이");
		}else {
			System.out.println("코끼리");
		}
		
		System.out.println(true ? "호랑이" : "코끼리");
		
		Tiger t = new Tiger();
		t.f1(3, 4);
		
		
		// 우박수 문제(삼항연산자로 표현)
		int num=1234567;
		while(true) {
			System.out.println(num);
			num = (num%2==0) ? num/2 : num*3+1;
			
			if(num==1) {
				System.out.println(num);
				break;
			}
		}

	}
}
class Tiger{
	int f1(int a, int b) {
//		if(a > b) {
//			return 1000;
//		}else {
//			return 2000;
//		}
		return a > b ? 1000 : 2000;
	}
}
*/


/*
//ex54)
interface Animal{
	abstract void cry();
}
class Dog implements Animal{
	public void cry() {System.out.println("멍멍");}
}
class Cat implements Animal{
	public void cry() {System.out.println("야옹");}
}
public class Hello {
	public static void main(String[] args) {
		Animal t = new Dog();
		t.cry();
	}
}
*/

/*
//ex53)
class Animal{
	void cry() {System.out.println("잉잉");}
}
class Dog extends Animal{
	void cry() {System.out.println("멍멍");}
}
class Cat extends Animal{
	void cry() {System.out.println("야옹");}
}
class Snake extends Animal{
	// cry() 구현없으면 부모를 따른다.
}
public class Hello {
	public static void main(String[] args) {
//		Dog t1 = new Dog();
//		Cat t2 = new Cat();
//		Snake t3 = new Snake();
//		
//		for (int i = 0; i < 5; i++) {
//			switch (new Random().nextInt(3)) {
//			case 0: t1.cry(); break;
//			case 1: t2.cry(); break;
//			case 2: t3.cry(); break;
//			default: break;
//			}			
//		}
//		int a, b, c;
//		int[] ar = new int[3];
//		Animal[] ani = new Animal[3];
//		ani[0] = new Dog();
//		ani[1] = new Cat();
//		ani[2] = new Snake();
		
		
// 		위의 코드와 동일한 코드이다.(이렇게 줄일수있다.)
		Animal[] ani = new Animal[] { new Dog(), new Cat(), new Snake()};
		for (int i = 0; i < 5; i++) {
			ani[new Random().nextInt(3)].cry();			
		}
	}
}
*/


/*
//ex52)업캐스팅을 하는 이유
class Animal{
	void cry() {
		System.out.println("잉잉");
	}
}
class Dog extends Animal{
	void cry() {
		System.out.println("멍멍");
	}
}
class Cat extends Animal{
	void cry() {
		System.out.println("야옹");
	}
}
class Snake extends Animal{
	// cry() 구현없으면 부모를 따른다.
}
class Zoo{
	// 1. upcasting을 하게 되면 이렇게 하나만으로 모든 cry() 동작을 할 수 있다
	// Animal ani = new Dog(), new Cat(), new Snake()
	void sound(Animal ani) {
		ani.cry();
	}
	
	
	// 2. upcasting을 안하게 되면 이렇게 동물이 추가될때마다 cry()를 추가해야함
	void sound(Dog dog) {
		dog.cry();
	}
	void sound(Cat cat) {
		cat.cry();
	}
	void sound(Snake snake) {
		snake.cry();
	}
}
public class Hello {
	public static void main(String[] args) {
		Animal t1 = new Dog();
		Animal t2 = new Cat();
		Animal t3 = new Snake();
		t1.cry();
		t2.cry();
		t3.cry();
		System.out.println("--------------------");
		
		Dog t4 = new Dog();
		Cat t5 = new Cat();
		Snake t6 = new Snake();
		t4.cry();
		t5.cry();
		t6.cry();
		System.out.println("--------------------");
		
		Zoo zoo = new Zoo();
		zoo.sound(new Dog());
		zoo.sound(new Cat());
		zoo.sound(new Snake());
	}
}
*/


/*
//ex51) 다형성(업캐스팅)
// 클래스의 결과나 인터페이스나 동일하다.
class A{
	void f1() {
		System.out.println(1);
	}
	void f2() {
		System.out.println(2);
	}
	void f3() {
		System.out.println("f3 call");
		f4(); // 자식꺼에도 있으면 부모꺼가 아닌 자식꺼를 실행시킨다.
	}
	void f4() {
		System.out.println("부모 f4");
	}
}
class B extends A{
	void f2() {
		System.out.println(3);
	}
	void f4() {
		System.out.println("자식 f4");
	}
}
public class Hello {
	public static void main(String[] args) {
		// 부 = 자
		A t = new B();
		t.f1();
		t.f2();
		t.f3();
	}
}
*/



/*
//ex50) 다형성
class A{
	void f1() {}
}

class B extends A{
	void f2() {}
}

public class Hello {
	public static void main(String[] args) {
		// 좌변은 문법 구사 / 우변은 할당메모리를 의미함
		// 상속과는 무관하다.
		A t1 = new A();
		t1.f1();
		
		
		// up casting(업캐스팅)
		A t2 = new B(); //문법적으로는 A만, 할당된 메모리는 둘다(가능)
		t2.f1();
		
		
		// 자바에서 지원하지 않는다.(다운캐스팅)
//		B t3 = new A(); // 문법적으로는 A,B 둘다, 할당된메모리는 A만(오류)
		
		
		// 자식것을 보고 없으면 부모것을 살펴본다.
		B t4 = new B();
		t4.f1();
		t4.f2();
	}
}
*/

/*
//ex49-2)
class A {void f1() {System.out.println(1);}}
interface B{void f2();}
interface C{void f3();}
class D extends A implements B, C{
	public void f2() {System.out.println(2);}
	public void f3() {System.out.println(3);}
}
public class Hello {
	public static void main(String[] args) {
		D t = new D();
		t.f1();
		t.f2();
		t.f3();
		
		StringBuffer sb;
	}
}
*/


/*
//ex49-1)
interface A{
	void f1();
}
interface B{
	void f2();
}
class C implements A, B{
	public void f1() {System.out.println(1);}
	public void f2() {System.out.println(2);}
}
public class Hello {
	public static void main(String[] args) {
		C t = new C();
		t.f1();
		t.f2();
	}
}
*/


/*
//ex48)
// abstract : 클래스이기 때문에 다중상속을 할 수 없다.
// interface 동일한 조건일때는 interface를 선택(다중상속을 할 수 있다.)
interface Tiger{
	abstract void f1();
	void f2();
}
class Lion implements Tiger{
	// interface에 있는 것을 구현한 함수는 반드시 public 이어야 한다.
	public void f1() {	System.out.println(1);}
	public void f2() {	System.out.println(2);}
}
public class Hello {
	public static void main(String[] args) {
		Lion t = new Lion();
		t.f1();
		t.f2();
	}
}
*/

/*
//ex47)
abstract class 대장장이{
	void 칼() {
		System.out.println("칼 만듦");
	}
	abstract void 방패();
}
class 병사1 extends 대장장이{
	void 방패() {
		System.out.println("드래곤이빨 방패 구해서 사용함");
	}
}
class 병사2 extends 대장장이{
	void 방패() {
		System.out.println("나무 방패 구해서 사용함");
	}
}
public class Hello {
	public static void main(String[] args) {
		병사1 t1 = new 병사1();
		t1.칼();
		t1.방패();
		병사2 t2 = new 병사2();
		t2.칼();
		t2.방패();
	}
}
*/

/*
//ex46)
abstract class Tiger{
	// 추상 함수이다.
	// 추상 함수를 1개라도 가지는 클래스는 반드시 추상 클래스이어야 한다.
	abstract void f1(); // 미완성코드(abstract : 추상)
	
	// 완성된 코드
	void f2() {
		System.out.println(1);
	}
}

// 상속받은 자식은 반드시 부모의 미완성코드를 완성해야 한다.
// 오버라이드(override) 문법을 이용해서
class Lion extends Tiger{
	void f1() {
		System.out.println(2);
	}
}

public class Hello {
	public static void main(String[] args) {
		// 추상 클래스는 객체 생성을 할 수 없다.
		// Tiger t = new Tiger();(X)
		Lion t = new Lion();
		t.f1();
		t.f2();
	}
}
*/

/*
//ex45)
// 자식은 부모이다.
// 사자는 호랑이이다.(X)
// 사자는 동물이다.(O) (is a)
class Tiger{}
class Animal{}
class Lion extends Animal{}

// 자식은 부모것을 가지고 있다.
// 경찰은 무기를 가지고 있다. (has a)
class Weapon{}
class Police extends Weapon{}


public class Hello {
	public static void main(String[] args) {
		Tiger t = new Tiger();
	}
}
*/


/*
//ex44) 다형성(polymorphism)
// n차 상속이 가능하다. 다중상속은 불가.
//f4키 누르면 상속계층도를 볼 수 있다.
class A{void f1() { System.out.println(1); }}
class B extends A{void f2() { System.out.println(2); }}
class C extends B{void f3() { System.out.println(3); }}
class D extends C{void f4() { System.out.println(4); }}
class F extends A{void f5() { System.out.println(5); }}

class G extends Object{
	
}

public class Hello {
	public static void main(String[] args) {
		D t1 = new D();
		t1.f4(); //f1() f2() f3() f4()
		
		F t2 = new F();
		t2.f5(); //f1() f5()
		
		String s;
		System.out.println(t2.hashCode());
	}
}
*/


/*
//ex43) 상속 : 기존클래스가 가지고 있는 기능을 확장하는 것이다.
// 단일 책임의 원칙 : 객체지향프로그램 개발의 5대 원칙중 1개
// <SOLID원칙>
// S 단일 책임 원칙 : 한 클래스는 하나의 기능만 가지는 원칙
// O 개방 폐쇄 원칙 : 확장에는 열려있으나 수정에는 닫혀있어야 한다
// L 리스코프 치환 원칙 : 상위타입은 반드시 하위 타입으로 대체할 수 있어야 한다
// I 인터페이스 분리 원칙 : 인터페이스 내에 메소드는 최소한일 수록 좋다
// D 의존관계 역전 원칙 : 구체적인 클래스보다 추상클래스나 인터페이스에 의존해야 한다
// 부모클래스
class Tiger{
	void f1() {
		System.out.println(1);
	}
	void f3() {
		System.out.println(31);
	}
}
// 자식클래스()
class Lion extends Tiger{
	void f2() {
		System.out.println(2);
	}
	void f3() { // override(부모클래스와 자식클래스에 있는 메소드가 동일할 때)
		System.out.println(32);
	}
	void f4() {
		//this.f3(); //자식 본인
		super.f3(); //부모
	}
}
// 윗 클래스를 확장해서 사용하세요. 기존기능 + 알파
public class Hello {
	public static void main(String[] args) {
		Lion t = new Lion();
		t.f1();
		t.f2();
		t.f3(); //부모클래스와 자식클래스에 있는 메소드가 동일할 때 자식꺼 호출
		t.f4();
	}
}
*/

/*
//ex42)
class Tiger{
	Lion f1(int a, String s, Tiger t, Lion l) {
		// return l;
		return new Lion();
	}
}
class Lion{
	
}
public class Hello {
	public static void main(String[] args) {
		Tiger t = new Tiger();
		t.f1(10, "호랑이", new Tiger(), new Lion());
	}
}
*/

/*
//ex41-4) this 용법4
class Tiger{
	int money=500;
	void f1() {
		System.out.println("tiger f1 call");
		Lion lion = new Lion();
		lion.merry(this); // this == t
	}
	void f3() {
		System.out.println("tiger f3 call");
	}
}
class Lion{
	void merry(Tiger t) {
		if (t.money > 600) {
			System.out.println("ok");
		}else {
			System.out.println("ng");
		}
		System.out.println("lion f2 call");
		t.f3();
	}
}
public class Hello {
	public static void main(String[] args) {
		Tiger t = new Tiger();
		t.f1();
	}
}
*/
//2022.10.27


////////////////////////////////////////////////
//ex 41-3) this 용법3
//class Tiger {
//	int x, y;
//	Tiger() {
//		System.out.println(1);
//	}
//
//	Tiger(int a) {
//		this(); // this 생성자 메서드는 첫 줄에 있어야 한다
//		x = a * 33;
//		System.out.println(2);
//	}
//
//	Tiger(int a, int b) {
//		this(a);
//		y = b;
//		System.out.println(3);
//	}
//}
//
//public class Hello {
//	public static void main(String[] args) {
//		Tiger t = new Tiger(10, 20);
//		System.out.println(t.x + " " + t.y);
//	}
//}

//ex 41-2) this 용법2-2
//class Tiger {
//	Tiger f1() {
//		System.out.println("아침먹고");
//		return this;
//	}
//	Tiger f2() {
//		System.out.println("점심먹고");
//		return this;
//	}
//	Tiger f3() {
//		System.out.println("저녁먹고");
//		return this;
//	}
//}
//public class Hello {
//	public static void main(String[] args) {
//		Tiger t = new Tiger();
//		// 체이닝 기법을 사용하는 이유는 코드의 난입을 막는 목적
//		t.f1().f2().f3();
//		
//		// 한 세트 개념이 아니다
//		t.f1();
//		t.f2();
//		t.f3();
//		
//		// 중간에 연관이 없는 코드가 난입했다
//		t.f1();
//		System.out.println("잔다.");
//		t.f2();
//		t.f3();
//	}
//}

//ex41-2) this 용법2-1
//함수 호출 체이닝을 위해서 사용된다
//class Tiger {
//	Tiger f1() {
//		System.out.println(this.hashCode());
//		return this;
//	}
//	Tiger f2() {
//		System.out.println("f2 call");
//		return this;
//	}
//	void f3() {
//		System.out.println("f3 call");
//	}
//}
//public class Hello {
//	public static void main(String[] args) {
//		Tiger t = new Tiger();
//		System.out.println(t.hashCode());
//		Tiger t2 = t.f1();
//		System.out.println(t2.hashCode());
//		System.out.println("-------------------------------------------------");
//		
//		Tiger tiger = new Tiger();
//		// chaining 기법
//		tiger.f1().f1().f1().f2().f2().f2().f2().f2().f2().f3();;
//	}
//}

//ex41-1) this 용법1
//생성자 함수의 인수명과 필드명을 구분하기 위하여 사용한다
//class Tiger {
//	String name;
//	int age;
//
//	Tiger() {
//	}
//	Tiger(String name, int age) {
//		this.name = name;
//		this.age = age;
//	}
//	@Override
//	public String toString() {
//		return "Tiger [name=" + name + ", age=" + age + "]";
//	}
//}
//public class Hello {
//	public static void main(String[] args) {
//		Tiger t = new Tiger("홍길동", 20);
//		System.out.println(t.toString());
//	}
//}

/*
//ex40) this 정의
//this : new를 이용해서 생성된 객체를 공유하는 변수 
class Tiger {
	int num = 10;
	Tiger() {
		// this = t; 공유가 되었다
		System.out.println(this.hashCode());
	
		//this.num = 20;
		num = 20;
	}
	
	void f1() {
	}
	void f2() {
		this.f2();
	}
}

public class Hello {
	public static void main(String[] args) {
		Tiger t = new Tiger();
		System.out.println(t.hashCode());
		t.num = 20;
		
		// 참조 변수 t,t2가 가르키는 객체가 다르다
		Tiger t2 = new Tiger();
	}
}
*/

//ex39) this 예시
//class Tiger {
//	String name;
//	int age;
//	
//	Tiger() {
//	}
//	Tiger(String name, int age) {
//		this.name = name;
//		this.age = age;
//	}
//	
//	@Override
//	public String toString() {
//		return "Tiger [name=" + name + ", age=" + age + "]";
//	}
//}
//
//public class Hello {
//	public static void main(String[] args) {
//		Tiger t = new Tiger("호랑이", 10);
//		System.out.println(t.toString());
//	}
//}

//ex 38) 인수전달 생성자
//class Tiger {
//	String name;
//	int age;
//
//	Tiger() {
//		name = "홍길동";
//		age = 20;
//	}
//
//	Tiger(String n, int a) {
//		name = n;
//		age = a;
//	}
//
//	void showData() {
//		System.out.println(name + " " + age);
//	}
//
//	@Override
//	public String toString() {
//		return "Tiger [name=" + name + ", age=" + age + "]";
//	}
//}
//
//public class Hello {
//	public static void main(String[] args) {
//		Tiger t1 = new Tiger();
//		t1.showData();
//		System.out.println(t1.toString());
//
//		// 인수 전달 생성자를 만들지 않으면 생성되는 모든 객체는 같은 값을 가진다
//		Tiger t2 = new Tiger();
//		t2.showData();
//
//		Tiger t3 = new Tiger("호랑이", 40);
//		t3.showData();
//	}
//}

//ex37) 기본생성자 
////class Tiger {
////	
////}
////class Tiger {
////	Tiger() {
////	}
////}
////위 두 코드는 동일한 코드이다
////생성자가 없으면 기본 생성자를 자동으로 만들어 준다
////만약 생성자를 만들게 된다면 기본 생성자를 만들지 않는다
//class Tiger {
//	Tiger() {
//	}
//	Tiger(int num) {
//	}
//}
//
//public class Hello {
//	public static void main(String[] args) {
//		// 객체는 생성될 때 무조건 생성자를 호출한다
////		Tiger t = new Tiger();
////		System.out.println(1);
//
//		// 기본 생성자가 없기 때문에 에러가 발생한다
//		// 그래서 원칙적으로 기본 생성자를 그냥 만들어준다
//		Tiger t = new Tiger();
//		System.out.println(1);
//	}
//}

//ex36 클래스 - 생성자 
//class Tiger {
//	// 1. 생성자 : 생성자 함수
//	// 2. 생성자도 함수이기 때문에 오버로딩이 가능
//	// 3. 함수이름이 반드시 클래스 이름과 동일해야 한다
//	// 4. 인수전달을 할 수 있지만 리턴값을 가질 수 없다
//	// 5. 목적은 멤버변수초기화가 유일한 목적
//	// 6. 객체가 생성(new)될 때 자동 호출이 되고 임의로 호출할 수 없다
//	
//	// 기본 생성자
//	Tiger() { 
//		System.out.println("생성자 콜1");
//	}
//	Tiger(int num) {
//		System.out.println("생성자 콜2");
//	}
//	void f1() {
//		System.out.println("f1 call");
//	}
//	void f2() {
//		// 스스로 자신의 클래스 타입으로 객체를 만들 수 있는가 ? YES
//		Tiger t = new Tiger();
//		// 사용하는 주체가 다르다
//		t.f1();
//		f1();
//	}
//}
//
//public class Hello {
//	public static void main(String[] args) {
//		System.out.println(1);
//		Tiger t = new Tiger();
//		System.out.println(2);
//		Tiger t2 = new Tiger(100);
//		System.out.println(3);
//	}
//}

////ex35) main 메서드
//public class Hello {
//	// 생성자를 가질 수 있다
//	// 필드를 가질 수 있다
//	// 메서드를 가질 수 있다
//	int count = 100;
//	void f1() {
//		
//	}
//	void f2() {
//		System.out.println(count);
//		f1();
//	}
//	static void f3() {
//		System.out.println("f3");
//	}
//	
//	// main()에 static이 없으면 따로 Hello 객체를 생성해야 한다
//	public static void main(String[] args) {
//		// static 안에서는 static만 사용할 수 있다
////		System.out.println(count); 
////		f1();
//		f3();
//		Hello h = new Hello();
//		h.f1();
//		h.f3();
//		
//	}
//}


/*
//ex34) static : 정적(고정)!= 동적(dynamic)
//static은 처음부터 메모리에 존재한다 (객체를 생성해서 사용할 필요가 없다)
//static은 속도와 연관 (객체를 생성하는 데 오랜 시간이 소요되기 때문)
class Tiger {
	static int count;
	
	static void f1() {
		System.out.println("call 1");
	}
	
	void f2() {
		System.out.println("call 2");
	}
	
	void f3() {
		f2(); // 인스턴스 메서드는 인스턴스 메서드를 호출할 수 있다
		System.out.println("call 3");
	}
	
	static void f4() {
		// static 메서드 안에서는 static 멤버만 사용할 수 있다
		// f2(); // static 메서드는 인스턴스 메서드를 호출할 수 없다 (객체가 생성됬는지 모르기 때문)
		f1();
	}
}
public class Hello {
	public static void main(String[] args) {
		Tiger.f1();
		Tiger t = new Tiger();
		t.f2(); // 인스턴스 메서드는 객체를 생성한 이후 사용할 수 있다
		t.f1(); // 객체를 생성해서 static메서드도 사용할수는 있다
		
		// abs() 역시 static 메서드(정수 절댓값 계산)
		System.out.println(Math.abs(-100));
		// 객체를 생성할 수 없는 이유는 Math클래스의 생성자가 private로 되어있기 때문이다
		// Math m = new Math();
		System.out.println(Math.PI);
		System.out.println("----------------------------------------------------------");
		t.f3();
	}
}
*/


//ex33) 오버로딩
//class Tiger {
//	// 오버로딩 규칙
//	// 1. 전달되는 인수의 개수가 다를 때
//	// 2. 인수의 개수가 같더라도 인수타입이 다를 때
//	void show() {
//		System.out.println(1);
//	}
//
//	void show(int num) {
//		System.out.println(2);
//	}
//
//	void show(int a, int b) {
//		System.out.println(3);
//	}
//
//	void show(short num) {
//		System.out.println(4);
//	}
//}
//
//class Point {
//	int x, y;
//}
//class Rect {
//	// int width, heigh;
//	int getArea(int w, int h) {
//		return w * h;
//	}
//	int getArea(Point s, Point e) {
//		int w = e.x - s.x;
//		int h = e.y - s.y;
//		return w * h;
//	}
//	int getArea(int x1, int y1, int x2, int y2) {
//		int w = x2 - x1;
//		int h = y2 - y1;
//		return w * h;
//	}
//}
//public class Hello {
//	public static void main(String[] args) {
//		Tiger t = new Tiger();
//		t.show();
//		t.show((int) 1);
//		t.show(2, 3);
//		t.show((short) 4);
//		Rect r = new Rect();
//		System.out.println(r.getArea(3, 4));
//		System.out.println(r.getArea(3, 4, 6, 8));
//		Point p1 = new Point();
//		Point p2 = new Point();
//		p1.x = 3; 
//		p1.y = 4; 
//		p2.x = 8; 
//		p2.y = 9; 
//		
//		System.out.println(r.getArea(p1, p2));
//	}
//}
////////////////////////////////////////////////


/*
//ex32)
class Lion{
	void cry() {
		System.out.println("어흥");
	}
}
class Tiger{
	String f1() {
		//String 타입의 클래스 객체가 리턴된다.
		return "호랑이";
	}
	Lion f2() {
		Lion lion = new Lion();
		return lion; // lion >> 확보받은 메모리
	} // Lion형으로 return
}
public class Hello {
	public static void main(String[] args) {
		Tiger t = new Tiger();
		System.out.println(t.f1());
		Lion l = t.f2(); // 공유되었다.
		l.cry();
	}
}
*/

/*
//ex31)
class Lion{
	void cry() {
		System.out.println("어흥");
	}
}
class Tiger {
	// int a = 10, String b = "호랑이", ch = '책'
	// String으로 인수 전달 받았다는 것은 클래스로 전달 받았다.
	void func(int a, String b, char ch, Lion lion) {
		System.out.println(a + b + ch);
		System.out.println("2 : " + lion.hashCode()); // 동일한 객체
		lion.cry();
	}
}
public class Hello {
	public static void main(String[] args) {
		Tiger t = new Tiger();
		Lion l = new Lion();
		System.out.println("1 : " + l.hashCode());
		t.func(10, "호랑이", '책', l);
	}
}
*/


/*
//ex30)
class Tiger{
	int func() {
		return 100;
	}
	void test() {
		
	}
}
public class Hello {
	public static void main(String[] args) {
		Tiger t = new Tiger();
		
		// 1. 버린다.
		t.func();
		
		// 2. 변수로 받아서 사용
		int num=t.func();
		System.out.println(num*10);
		
		// 3. 바로 출력으로 연결.
		System.out.println(t.func());
		
		// 출력으로 연결시킬수없다.
//		System.out.println(t.test());
	}
}
*/

/*
//ex29)
class Tiger{
	// void f1()만 함수 원형(prototype)
	//1
	void f1() {
		System.out.println(1);
	}
	//2
	void f2(int a) { // 인수 전달은 1개 이상 할 수 있다.
		System.out.println(2);
	}
	//3
	int f3() { // 리턴은 1개만 할 수 있다.
		System.out.println(3);
		return 0;
	}
	//4
	int f4(int a) {
		System.out.println(4);
		return 0;
	}
}
public class Hello {
	public static void main(String[] args) {
		Tiger t = new Tiger();
		t.f1();
		t.f2(10);
		t.f3();
		t.f4(0);
	}
}
*/


/*
//ex28)
class Person {
	// 필드는 외부에 오픈시키지 않는다.
	// 데이터 은닉
	private String name="홍길동";
	private int age=20;
	
	public void setName(String n) {
		this.name=n;
	}
	public int getAge() {
		return age;
	}
	public String getName() {
		return name;
	}
	
}
public class Hello {
	public static void main(String[] args) {
		Person p1=new Person();
		p1.setName("강길동");
		System.out.println(p1.getName());
		
		// 이렇게 쓰면 안된다.
		//p1.name="강길동";
		//p1.age=30;
		//System.out.println(p1.name + " " + p1.age);
	}
}
*/


/*
//ex27)
class Tiger{
	int num;
	float count;
	String str;
}
public class Hello {
	public static void main(String[] args) {
		Tiger t1 = new Tiger();
		Tiger t2 = new Tiger();
		t1.num=10;
		t1.count=20.0f;
		t1.str="호랑이1";
		System.out.println(t1.num);
		
		t2.num=30;
		t2.count=40.0f;
		t2.str="호랑이2";
		System.out.println(t2.num);
	}
}
*/



/*
//ex26) 클래스
//클래스의 3대요소 : 생성자, 필드, 메소드
//GOF의 디자인 패턴
// 1. 파일 1개당 클래스 1개가 원칙이다.
// 2. 파일명은 클래스명과 동일하게 하는게 원칙이다.
// 3. 클래스명의 첫자는 대문자, 파일명의 첫자는 소문자
// 4. 1개의 파일에 여러개의 클래스가 들어갈 수 있는데
// 		반드시 1개만 public 이어야 한다.
// 5. Person 설계도이다.
//	1. 생성자
//	2. 필드(field) >> 변수
//	3. method     >> 함수(function)
// 6. 객체 생성 방법
// Person person = new Person();
class Person{
	
}
public class Hello {
	public static void main(String[] args) {
		// new는 메모리를 사용하는 것이다.
		Person p1 = new Person();
		Person p2 = new Person();
		Person p3 = new Person();
		System.out.println(p1.hashCode());
		System.out.println(p2.hashCode());
		System.out.println(p3.hashCode());
		
		//서로 다른 이름으로 객체를 공유했다.
		//서로 다른 이름으로 객체를 참조(reference)했다.
		//사회 : 홍길동, 집 : 곰돌이
		Person p4=p1;
		System.out.println(p4.hashCode());
		
		// 메모리 반납코드가 있어야 하는 것이 원칙인데
		// 자바는 사용하지 않는다고 판단이 되면 자동 반납이다.
		// 자바가 메모리를 가비지 콜렉션을 한다.
		
	}
}
*/
// 2022.10.26







/*
//ex25) random 세로 더하기
import java.util.Random;
public class Hello {
	public static void main(String[] args) {
		Random rn = new Random();
		int[][] arr = new int[3][4];
		int[] sum = new int[4];
		
		for (int i = 0; i < 3; i++) {
			for (int j = 0; j < 4; j++) {
				arr[i][j] = rn.nextInt(10);
			}
		}
		// 원본 출력
		for (int i = 0; i < 3; i++) {
			for (int j = 0; j < 4; j++) {
				System.out.print(arr[i][j] + " ");
			}System.out.println();
		}
		
		// 덧셈하고 출력
		for (int j = 0; j < 4; j++) {
			for (int i = 0; i < 3; i++) {
				sum[j] += arr[i][j];
			}
			System.out.print(sum[j] + " ");
		}
	}
}
*/


/*
//ex24) random
import java.util.Random;
public class Hello {
	public static void main(String[] args) {
		Random rn = new Random();
		for (int i = 0; i < 10; i++) {
			// ex1)
			// +- 20억 사이의 숫자를 랜덤하게 얻는다.
			// int num = rn.nextInt();
			// System.out.println(num);
			
			// ex2)
			// 0~9
			// 0 <= x < 10
			System.out.print(rn.nextInt(10) + " ");
		}System.out.println();
		for (int i = 0; i < 10; i++) {
			System.out.print(new Random().nextInt(100) + " ");
		}System.out.println();
		System.out.println();
		
		for (int i = 0; i < 3; i++) {
			for (int j = 0; j < 4; j++) {
				int num = rn.nextInt(10);
				System.out.print(rn.nextInt(10) + " ");
			}System.out.println();
		}
	}
}
*/



/*
//ex23)
public class Hello {
	public static void main(String[] args) {
		int[] arr = new int[3];
		int[][] brr = new int[5][3]; // [세로길이][가로길이]
		int[][][] crr = new int[2][5][3]; // [세로길이][가로길이]
		System.out.println("test1 : " + brr.length);
		System.out.println("test2 : " + brr[0].length);
		
		for (int i = 0; i < brr.length; i++) {
			for (int j = 0; j < brr[0].length; j++) {
				brr[i][j] = i*brr[0].length+j;
			}
		}
		
		for (int i = 0; i < 5; i++) {
			for (int j = 0; j < 3; j++) {
				System.out.printf("%3d", brr[i][j]);
			}System.out.println();
		}
	}
}
*/


/*
//ex22)
class Tiger{
	
}
public class Hello {
	public static void main(String[] args) {
//		String s2=new String("호랑이");
//		Tiger t1=new Tiger();
		
		String[] t1   =new String[3];
		Tiger[] t2    =new Tiger[3];
		
		String[] t31  =new String[] {new String("호"), new String("랑")};
		String[] t32  =new String[] {"호", "랑"};
		Tiger[] t4    =new Tiger[] {new Tiger(), new Tiger()};
		
		String[] t51  ={new String("호"), new String("랑")};
		String[] t52  ={"호", "랑"};
		Tiger[] t6    ={new Tiger(), new Tiger()};
		
		// 클래스 : String
		// 클래스
		// 객체지향프로그래밍
	}
}
*/





/*
//ex21)
class Tiger {
	void f1() {
		System.out.println("call");
	}
}
public class Hello {
	public static void main(String[] args) {
		Tiger[] arr = new Tiger[3];
		for (int i = 0; i < arr.length; i++) {
			arr[i] = new Tiger();
		}
		
		for (int i = 0; i < arr.length; i++) {
			arr[i].f1();
		}
		
		Tiger[] brr=new Tiger[] {
				new Tiger(), 
				new Tiger(), 
				new Tiger()
		};
		for (Tiger obj : brr) {
			obj.f1();
		}
		Tiger[] crr=new Tiger[] {
				new Tiger(), 
				new Tiger(), 
				new Tiger()
		};
	}

}
*/




/*
//ex20)
public class Hello {
	public static void main(String[] args) {
		String[] arr=new String[4];
		
		arr[0]=new String("앵무새0");
		arr[0]="앵무새0";
		
		arr[1]="앵무새1";
		arr[2]="앵무새2";
		arr[3]="앵무새3";
		String[] brr=new String[] {
			new String("호랑이"), 
			"코끼리", 
			"독수리"};
		String[] crr={"호랑이1", "코끼리1", "독수리1"};
		System.out.println(arr[2]);
		for (int i = 0; i < brr.length; i++) {
			System.out.print(brr[i] + " ");
		}System.out.println();
		for (String value : crr) {
			System.out.print(value + " ");
		}System.out.println();
	}
}
*/


/*
//ex19) 배열
public class Hello {
	public static void main(String[] args) {
		int a=10; //일반변수
		
		// array
		// 방법1
		int[] arr=new int[5];
		// 방법2
		int[] brr=new int[] {1,2,3,4};
		// 방법3
		int[] crr= {1,2,3,4,5,6};
		System.out.println(arr.length);
		System.out.println(brr.length);
		System.out.println(crr.length);
		
		for(int i=0;i<brr.length;i++) {
			System.out.print(brr[i] + " ");
		}System.out.println();
		
		// i, value, item, x
		// foreach
		for (int value : crr) {
			System.out.print(value + " ");
		}System.out.println();
		
		//
		int[] drr=new int[5];
		// 0~4
		// ArrayIndexOutOfBoundsException
		// drr[5] = 100;
		drr[2] = 100;
		drr[2*5-7] = 100;
		drr[4] = 2;
		drr[drr[4]*3-5] = 999;
	}
}
*/


/*
//ex18) 우박수 문제
public class Hello {
	public static void main(String[] args) {
		int num=1234567;
		while(true) {
			System.out.println(num);
			if(num%2==0) {
				num=num/2;
			}else {
				num=num*3+1;
			}
			
			if(num==1) {
				System.out.println(num);
				break;
			}
		}
	}
}
*/


/*
//ex17)
// for : 정확하게 반복횟수를 알고 있을 때
// while : 프로그래머가 반복횟수를 모를때...
public class Hello {
	public static void main(String[] args) {
		int num=0;
		// ex1)
		while(num<4) {
			System.out.println(num++);
		}
		// ex2)
		while(true) {
			System.out.println(num++);
			if(num==33) {
				System.out.println("탈출 일보직전");
				break;
			}
		}
	}
}
*/

/*
//ex16)
public class Hello {
	public static void main(String[] args) {
		//1. case 뒤에는 변수가 올 수 없다.
		//2. switch에는 변수를 사용할 수 있다.
		//3. case뒤에 숫자가 중복될 수 없다.
		//4. 자바 버전에 따라서 문자열/문자를 분기시킬 수 있다.
		//5. 일반적으로 case break는 한쌍인데 의도적으로 break를 생략할 수 있다.
		int num=200;
		String s="독수리";
		
		switch (s) {
		
		case "독수리":
			System.out.println(1);
			break;
		case "코끼리":
			System.out.println(1);
			break;
			
		default: break;
		}
		
		switch (s) {
		case "독수리": //break;
		case "코끼리":
			System.out.println("동물입니다.");
			break;
		case "소나무": //break;
		case "대나무":
			System.out.println("식물입니다.");
			break;
			
		default: break;
		}
		
		int jumsu=80;
		switch(jumsu/10) {
		case 10: //break;
		case 9:
			System.out.println("A");
			break;
		case 8:
			System.out.println("B");
			break;
		default:
			break;
		}
	}
}
*/



//ex15) for in for
//public class Hello {
//	public static void main(String[] args) {
//		// ex1)
//		// 격자형태(테이블형태, 맵형태)
//		for(int i=0;i<3;i++) {
//			for (int j = 0; j < 4; j++) {
//				System.out.print("[" + i + " " + j + "]");
//			}
//			System.out.println();
//		}System.out.println();
//		
//		// ex2)
//		// 격자형태(테이블형태, 맵형태)
//		for(int i=0;i<3;i++) {
//			for (int j = 0; j < 4; j++) {
//				System.out.print(" * ");
//			}
//			System.out.println();
//		}System.out.println();
//		
//		// ex3)
//		int width=4, height=3;
//		for(int i=0;i<height;i++) {
//			for (int j = 0; j < width; j++) {
////				System.out.print(i*width+j);
//				System.out.printf("%2d", i*width+j);
//			}
//			System.out.println();
//		}System.out.println();
//		
//		System.out.printf( "호랑이\n" );
//		System.out.printf( "코끼리\n" );
//		System.out.printf( "코%d끼%d리%d\n", 777, 888, 999 );
//		System.out.printf("%d\n", 3);
//		System.out.printf("%4d\n", 3);
//		System.out.printf("%04d\n", 3);
//		
//		int a=10, b=20, c=30;
//		String s = String.format("무궁화:%d 소나무:%d 백합:%d", 10, 20, 30);
//		System.out.println("output : " + s);
//		
//		//ex4)
//		for(int i=0;i<3;i++)
//			for(int j=0;j<4;j++)
//				System.out.println("test");
//		
//		//ex5)
//		for(int i=0;i<3;i++) {
//			for(int j=0;j<4;j++)
//				System.out.println("apple");
//			
//			System.out.println("banana");
//		}
//		
//		//ex6)
//		//for(int i=0;i<3;i++);
//		int count;
//		for(count=0; count<3; count++);
//		
//		System.out.println(count);
//	}
//}


//ex14)
//public class Hello {
//	// int a = n1++;
//	// int b = ++n2;
//	static void f1(int a, int b) {
//		System.out.println(a + " " + b);
//	}
//	public static void main(String[] args) {
//		int a = 3;
//		int b = a++; //1. 대입 2. 증가
//		System.out.println(a + " " + b);
//		
//		int c = 3;
//		int d = ++c; //1. 증가 2. 대입
//		System.out.println(c + " " + d);
//		int n1=3, n2=3;
//		System.out.println("-------------------------");
//		f1(n1++, ++n2);
//		n1++;
//		++n2;
//		// 자료가 10이 있을때
//		// 이 자료를 순회하면서 하나씩 가져오거나 저장할때
//		// 일반적으로 이터레이터를 사용하게 되는데
//		// 이터레이터 연산 중에서
//		// 이터레이터++
//		// ++이터레이터
//		// 라는 두 명령이 존재한다.
//		// 이때 두 명령의 실행속도는 30배정도 차이가 난다.
//		// ++이터레이터가 30배정도 빠르다.
//		// 그래서
//	}
//}

//ex13)
//public class Hello {
//	public static void main(String[] args) {
//		// 1만 증가 시킨다는 전제 아래에서
//		int num=0;
//		//대입연산과 덧셈연산이 사용된다.
//		// move, add 어셈블리어로 번역
//		num=num+1;
//		System.out.println(num);
//		// inc
//		// num++, ++num은 속도가 똑같다.
//		num++;
//		System.out.println(num);
//		++num;
//		System.out.println(num);
//		
//		num+=1; // 약간 좋다.
//		System.out.println(num);
//		
//		int test=10;
//		int count=20;
//		test+=count;
//		// test = test + count;
//	}
//}


//ex12)
//public class Hello {
//	public static void main(String[] args) {
//		char ch = 'A'; //문자 'A'의 아스키코드값은 65
//		// println ch가 무슨 타입인지 확인한다.
//		// 문자타입이라고 확인하고 숫자를 아스키문자로 출력한것이다.
//		System.out.println(ch);
//		// 강제 형 변환(단, 현재 라인에서만 적용된다.)
//		// 강제 형 변환(타입캐스팅)
//		System.out.println((int)ch);
//		System.out.println(65);
//		System.out.println((char)65);
//		int num = 65;
//		System.out.println(num);
//		System.out.println((char)num);
//		System.out.println("-------------------------");
//		
//		char ch2='A';
//		for(int i=0;i<26;i++) {
//			System.out.println((char)(ch2+i));
//		}
//	}
//}


//ex11)
//public class Hello {
//	public static void main(String[] args) {
//		// 기본코드1
//		int num=5;
//		for(int i=0;i<10;i++) {
//			System.out.println(num+ " * " + i + " = " + num*i);
//		}
//		// 기본코드2
//		int sum=0;
//		num = 10;
//		for (int i = 0; i <= num; i++) {
//			//sum = sum + i;
//			sum+=i; // 복합대입연산자
//		}
//		System.out.println(sum);
//		
//	}
//}



// ex10) for
//public class Hello {
//	public static void main(String[] args) {
//		// 정석코드1
//		for (int i = 0; i < 4; i++) {
//			System.out.println(i);
//		}
//		// 정석코드2
//		for (int i = 1; i <= 4; i++) {
//			System.out.println(i);
//		}
//		// 정석코드3
//		// 4*2+1번
//		int aa=4;
//		for (int i = -aa; i <= aa; i++) {
//			System.out.println(i);
//		}
//		// bad code
//		for(int i=0;i<=4;i++) {
//			System.out.println(i);
//		}
//		for(int i=2;i<=4;i++) {
//			System.out.println(i);
//		}
//		for(int i=2;i<=4;i+=2) {
//			System.out.println(i);
//		}
//		for(int i=2;i>4;i+=2) {
//			System.out.println(i);
//		}
//	}
//}



// ex9) if
//public class Hello {
//	public static void main(String[] args) {
//		// if for while switch
//		
//		// ex1)
//		// if(true)
//		// if(3>2)
//		// if(true||false)
//		if(true) {
//			System.out.println(1);
//			System.out.println(2);
//		}
//		// scope 생략 가능
//		if(true)
//			System.out.println(3);
//		
//		// ex2)
//		int num=10;
//		if(num%2==0) {
//			System.out.println("짝수");
//		}else {
//			System.out.println("홀수");
//		}
//		
//		// ex3) n개중에 1개를 선택
//		if(false) {
//			System.out.println(10);
//		}else if(false) {
//			System.out.println(20);
//		}else if(true) {
//			System.out.println(30);
//		}else {
//			System.out.println(40);
//		}
//		
//		// ex4)
//		if(true) {
//			if(false) {
//				if(true) {
//					
//				}
//			}else {
//				if(true) {
//					
//				}else if(false) {
//					
//				}else {
//					
//				}
//			}
//		}
//	}
//}


// ex8) 논리연산(관계연산)
//public class Hello {
//	public static void main(String[] args) {
//		// and(&&), or(||), not(부정)
//		System.out.println(false && false);
//		System.out.println(false && true);
//		System.out.println(true && false);
//		System.out.println(true && true);
//		System.out.println("------------------");
//		System.out.println(false || false);
//		System.out.println(false || true);
//		System.out.println(true || false);
//		System.out.println(true || true);
//		System.out.println("------------------");
//		boolean test=true;
//		System.out.println(!test);
//		System.out.println(!(10>20));
//		
//		System.out.println( true && true && true && false );
//		System.out.println( !(false && true && false && false) );
//		
//		// 연산자 우선순위 : 산술 > 관계(비교) > 논리
//		System.out.println(
////			3+2>2 && 4-2<10 && 3*3>=8
////			5>2 && 2<10 && 9>=8
////			true && true && true
//				);
//		// 아래 프로그램은 잘못 작성된 예이다.
//		// 코드의 가독성이 떨어진다.
//		// System.out.println(true && true || true);
//		// 연산자 우선순위를 결정해서 적어주는 것이 좋다.
//		System.out.println((true && true) || true);
//		System.out.println(true && (true || true));
//		
//		
//	}
//}


//ex7) 비교연산(관계연산)
//public class Hello {
//	public static void main(String[] args) {
//		// 산술연산
//		System.out.println(3>2);
//		System.out.println(3<2);
//		System.out.println(3>=2);
//		System.out.println(3<=2);
//		System.out.println(3==2);
//		System.out.println(3!=2);
//		
//		
//	}
//}



// ex6) 산술연산/문자열 연결
//public class Hello {
//	public static void main(String[] args) {
//		System.out.println(27 + 4);
//		System.out.println(27 - 4);
//		System.out.println(27 * 4);
//		System.out.println(27 / 4); //몫
//		// result : 0 ~ 3
//		System.out.println(27 % 4); //나머지
//		
//		System.out.println(27+4);
//		// 왼쪽에서 오른쪽으로 해석한다.
//		// 숫자 + 문자열 = 문자열
//		// 문자열 + 숫자 = 문자열
//		// 문자열 + 문자열 = 문자열
//		System.out.println(27+"호랑이");
//		System.out.println("호랑이"+27);
//		System.out.println("호랑이" + "코끼리");
//		System.out.println(27+13+"호랑이");
//		System.out.println(40+"호랑이");
//		System.out.println("호랑이" + 27 + 13);
//		System.out.println(27 + "호랑이" + 13);
//		System.out.print(27 + " " + 13);
//		int a = 10, b = 20;
//		System.out.println(a + " " + b);
//		// 문자 : 1개
//		// 문자열 : 0개이상
//	}
//}
//


// ex5) 표기법 정리
//public class Hello {
//	public static void main(String[] args) {
//		// 카멜표기법
//		int appleNum = 10;
//		// 파스칼표기법 : 맨앞에 오는 글자 대문자로 표기 + 카멜표기법
//		int TotalNumber = 10;
//		// 헝가리안표기법 : 접두어에 자료형을 알아볼 수 있게 표기
//		String strName;
//		// 스네이크 표기법 : 단어 사이에 언더바를 넣어서 표기
//		int total_number;
//	}
//}


// ex4)
//public class Hello {
//	public static void main(String[] args) {
//		short a = 200;
//		System.out.println(Short.MAX_VALUE);
//		System.out.println(Short.MIN_VALUE);
//		System.out.println(Long.MAX_VALUE);
//		System.out.println(Long.MIN_VALUE);
//		System.out.println(Integer.MAX_VALUE);
//		System.out.println(Integer.MIN_VALUE);
//		System.out.println(Character.MAX_VALUE);
//		System.out.println(Character.MIN_VALUE);
//		
//		int b = 10;
//		if (b < Short.MAX_VALUE) {
//			
//		}
//	}
//}

// ex03)
//public class Hello {
//	public static void main(String[] args) {
//		// type(형) int
//		// >> int, double, float, short, long, char, boolean, byte
//		// 8가지
//		// byte(1) : +- 127
//		// short(2) : +- 3xxxx
//		// char(2) : 문자 전용(0~65535)
//		// int(4) : 정수 전용 2^32(+- 20억)
//		// long(8) : 8byte 정수
//		// float(4) : 실수 전용(3.14)
//		// double(8) : 8byte 실수
//		// boolean(1) : true/false
//		
//		int a = 10;
//		double sum = 0.0;
//		for (int i=0;i<100;i++) {
//			sum+=0.1f;
//		}
//		System.out.println(sum);
//		
//	}
//}
// 2022.10.25

// ex1) 환경설정
// ex2) 
//public class Hello {
//	public static void main(String[] args) {
//		System.out.println("호랑이1");
//		System.out.println("호랑이2");
//		System.out.println("호랑이3");
//		System.out.println("호랑이4");	
//	}
//}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-28 14:18:18.746
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-28 14:18:18.748
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2022-10-31 09:08:43.255 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-10-31 09:09:07.559
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-31 09:09:07.559
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-31 09:09:07.559
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-10-31 09:09:11.922
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\BIT'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-10-31 15:53:51.887 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-10-31 15:54:13.888
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-31 15:54:13.888
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-31 15:54:13.888
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-10-31 15:54:18.038
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\BIT'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-11-01 08:58:38.080 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-11-01 08:59:02.241
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-01 08:59:02.241
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-01 08:59:02.241
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-11-01 08:59:06.656
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\BIT'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-11-02 09:01:16.405 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-11-02 09:01:40.516
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-02 09:01:40.516
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-02 09:01:40.516
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-11-02 09:01:45.872
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\BIT'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.core.resources 4 2 2022-11-02 10:48:00.763
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.core.resources".
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.internal.compiler.env.IModule.isAutomatic()" because "module" is null
	at org.eclipse.jdt.internal.compiler.lookup.BinaryModuleBinding.create(BinaryModuleBinding.java:99)
	at org.eclipse.jdt.internal.compiler.impl.ITypeRequestor.accept(ITypeRequestor.java:65)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getModuleFromAnswer(LookupEnvironment.java:437)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForTypeFromModules(LookupEnvironment.java:374)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:236)
	at org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve(UnresolvedReferenceBinding.java:114)
	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveType(BinaryTypeBinding.java:249)
	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.superInterfaces(BinaryTypeBinding.java:2414)
	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.detectHierarchyCycle(ClassScope.java:1600)
	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.detectHierarchyCycle(ClassScope.java:1538)
	at org.eclipse.jdt.internal.compiler.ast.SingleTypeReference.getTypeBinding(SingleTypeReference.java:73)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.internalResolveType(TypeReference.java:522)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:634)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:630)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveSuperType(TypeReference.java:602)
	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.findSupertype(ClassScope.java:1670)
	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.connectSuperclass(ClassScope.java:1176)
	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.connectTypeHierarchy(ClassScope.java:1454)
	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.connectTypeHierarchy(CompilationUnitScope.java:394)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.completeTypeBindings(LookupEnvironment.java:518)
	at org.eclipse.jdt.internal.compiler.Compiler.internalBeginToCompile(Compiler.java:881)
	at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:394)
	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:444)
	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:426)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:379)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.compile(BatchImageBuilder.java:214)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:311)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:79)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:273)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildDeltas(JavaBuilder.java:295)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:213)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:1024)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:254)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:311)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:400)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:403)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:514)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:462)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:544)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:161)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:255)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.core.resources 4 75 2022-11-02 10:48:00.771
!MESSAGE Errors occurred during the build.
!SUBENTRY 1 org.eclipse.jdt.core 4 75 2022-11-02 10:48:00.771
!MESSAGE Errors running builder 'Java Builder' on project 'ChatServer'.
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.internal.compiler.env.IModule.isAutomatic()" because "module" is null
	at org.eclipse.jdt.internal.compiler.lookup.BinaryModuleBinding.create(BinaryModuleBinding.java:99)
	at org.eclipse.jdt.internal.compiler.impl.ITypeRequestor.accept(ITypeRequestor.java:65)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getModuleFromAnswer(LookupEnvironment.java:437)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForTypeFromModules(LookupEnvironment.java:374)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:236)
	at org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve(UnresolvedReferenceBinding.java:114)
	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveType(BinaryTypeBinding.java:249)
	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.superInterfaces(BinaryTypeBinding.java:2414)
	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.detectHierarchyCycle(ClassScope.java:1600)
	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.detectHierarchyCycle(ClassScope.java:1538)
	at org.eclipse.jdt.internal.compiler.ast.SingleTypeReference.getTypeBinding(SingleTypeReference.java:73)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.internalResolveType(TypeReference.java:522)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:634)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:630)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveSuperType(TypeReference.java:602)
	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.findSupertype(ClassScope.java:1670)
	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.connectSuperclass(ClassScope.java:1176)
	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.connectTypeHierarchy(ClassScope.java:1454)
	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.connectTypeHierarchy(CompilationUnitScope.java:394)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.completeTypeBindings(LookupEnvironment.java:518)
	at org.eclipse.jdt.internal.compiler.Compiler.internalBeginToCompile(Compiler.java:881)
	at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:394)
	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:444)
	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:426)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:379)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.compile(BatchImageBuilder.java:214)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:311)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:79)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:273)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildDeltas(JavaBuilder.java:295)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:213)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:1024)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:254)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:311)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:400)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:403)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:514)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:462)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:544)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:161)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:255)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2022-11-02 14:30:01.244
!MESSAGE Disconnected before saving. Please post stacktrace to https://bugs.eclipse.org/bugs/show_bug.cgi?id=569286 org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor ChatServer.java
!STACK 0
java.lang.IllegalStateException: Disconnected before saving. Please post stacktrace to https://bugs.eclipse.org/bugs/show_bug.cgi?id=569286 org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor ChatServer.java
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.disconnectEditor(AbstractTextEditor.java:7136)
	at org.eclipse.ui.texteditor.AbstractTextEditor.dispose(AbstractTextEditor.java:4327)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.dispose(AbstractDecoratedTextEditor.java:392)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.dispose(JavaEditor.java:2666)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.dispose(CompilationUnitEditor.java:1513)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.invalidate(CompatibilityPart.java:264)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.destroy(CompatibilityPart.java:421)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:995)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:960)
	at org.eclipse.e4.core.internal.di.InjectorImpl.uninject(InjectorImpl.java:201)
	at org.eclipse.e4.core.internal.di.Requestor.uninject(Requestor.java:177)
	at org.eclipse.e4.core.internal.contexts.ContextObjectSupplier$ContextInjectionListener.update(ContextObjectSupplier.java:89)
	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:103)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.removeListenersTo(EclipseContext.java:487)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.uninject(ContextInjectionFactory.java:184)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:947)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.subscribeTopicToBeRendered(PartRenderingEngine.java:185)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.di.internal.extensions.EventObjectSupplier$DIEventHandler.handleEvent(EventObjectSupplier.java:92)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setToBeRendered(UIElementImpl.java:314)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.hidePart(PartServiceImpl.java:1401)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.hidePart(PartServiceImpl.java:1331)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.closePart(StackRenderer.java:1182)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer$3.close(StackRenderer.java:1042)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1961)
	at org.eclipse.swt.custom.CTabFolder.lambda$0(CTabFolder.java:337)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	Suppressed: java.lang.IllegalStateException: isDirty check after disconnect
		at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7185)
		at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3431)
		at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3404)
		at org.eclipse.ui.ide.IDE$1.run(IDE.java:1458)
		at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
		at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1446)
		at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
		at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
		at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
		at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
		at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:172)
		at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
		at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:132)
		at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4043)
		at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3648)
		... 21 more

!ENTRY org.eclipse.core.resources 4 2 2022-11-02 19:39:52.901
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.core.resources".
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.internal.compiler.env.IModule.isAutomatic()" because "module" is null
	at org.eclipse.jdt.internal.compiler.lookup.BinaryModuleBinding.create(BinaryModuleBinding.java:99)
	at org.eclipse.jdt.internal.compiler.impl.ITypeRequestor.accept(ITypeRequestor.java:65)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getModuleFromAnswer(LookupEnvironment.java:437)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForTypeFromModules(LookupEnvironment.java:374)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:236)
	at org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve(UnresolvedReferenceBinding.java:114)
	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveType(BinaryTypeBinding.java:249)
	at org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getType(PackageBinding.java:205)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findType(Scope.java:2027)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java:3502)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:3189)
	at org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference.getTypeBinding(ArrayTypeReference.java:115)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.internalResolveType(TypeReference.java:522)
	at org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference.internalResolveType(ArrayTypeReference.java:202)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:625)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:621)
	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.resolveTypesWithSuspendedTempErrorHandlingPolicy(SourceTypeBinding.java:2803)
	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.resolveTypesFor(SourceTypeBinding.java:2705)
	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.methods(SourceTypeBinding.java:2276)
	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.internalFaultInTypeForFieldsAndMethods(SourceTypeBinding.java:1518)
	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.faultInTypesForFieldsAndMethods(SourceTypeBinding.java:1113)
	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.faultInTypes(CompilationUnitScope.java:560)
	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:898)
	at org.eclipse.jdt.internal.compiler.ProcessTaskManager.run(ProcessTaskManager.java:145)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.core.resources 4 75 2022-11-02 19:39:52.907
!MESSAGE Errors occurred during the build.
!SUBENTRY 1 org.eclipse.jdt.core 4 75 2022-11-02 19:39:52.907
!MESSAGE Errors running builder 'Java Builder' on project 'ChatServer'.
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.internal.compiler.env.IModule.isAutomatic()" because "module" is null
	at org.eclipse.jdt.internal.compiler.lookup.BinaryModuleBinding.create(BinaryModuleBinding.java:99)
	at org.eclipse.jdt.internal.compiler.impl.ITypeRequestor.accept(ITypeRequestor.java:65)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getModuleFromAnswer(LookupEnvironment.java:437)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForTypeFromModules(LookupEnvironment.java:374)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:236)
	at org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve(UnresolvedReferenceBinding.java:114)
	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveType(BinaryTypeBinding.java:249)
	at org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getType(PackageBinding.java:205)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findType(Scope.java:2027)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java:3502)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:3189)
	at org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference.getTypeBinding(ArrayTypeReference.java:115)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.internalResolveType(TypeReference.java:522)
	at org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference.internalResolveType(ArrayTypeReference.java:202)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:625)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:621)
	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.resolveTypesWithSuspendedTempErrorHandlingPolicy(SourceTypeBinding.java:2803)
	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.resolveTypesFor(SourceTypeBinding.java:2705)
	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.methods(SourceTypeBinding.java:2276)
	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.internalFaultInTypeForFieldsAndMethods(SourceTypeBinding.java:1518)
	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.faultInTypesForFieldsAndMethods(SourceTypeBinding.java:1113)
	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.faultInTypes(CompilationUnitScope.java:560)
	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:898)
	at org.eclipse.jdt.internal.compiler.ProcessTaskManager.run(ProcessTaskManager.java:145)
	at java.base/java.lang.Thread.run(Thread.java:833)
!SESSION 2022-11-02 21:47:00.632 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-11-02 21:47:24.956
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-02 21:47:24.956
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-02 21:47:24.956
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-11-02 21:47:29.063
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\BIT'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.core.resources 4 2 2022-11-02 21:48:28.576
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.core.resources".
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.internal.compiler.env.IModule.isAutomatic()" because "module" is null
	at org.eclipse.jdt.internal.compiler.lookup.BinaryModuleBinding.create(BinaryModuleBinding.java:99)
	at org.eclipse.jdt.internal.compiler.impl.ITypeRequestor.accept(ITypeRequestor.java:65)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getModuleFromAnswer(LookupEnvironment.java:437)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForTypeFromModules(LookupEnvironment.java:374)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:236)
	at org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve(UnresolvedReferenceBinding.java:114)
	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveType(BinaryTypeBinding.java:249)
	at org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getType(PackageBinding.java:205)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findType(Scope.java:2027)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java:3502)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:3189)
	at org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference.getTypeBinding(ArrayTypeReference.java:115)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.internalResolveType(TypeReference.java:522)
	at org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference.internalResolveType(ArrayTypeReference.java:202)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:625)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:621)
	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.resolveTypesWithSuspendedTempErrorHandlingPolicy(SourceTypeBinding.java:2803)
	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.resolveTypesFor(SourceTypeBinding.java:2705)
	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.methods(SourceTypeBinding.java:2276)
	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.internalFaultInTypeForFieldsAndMethods(SourceTypeBinding.java:1518)
	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.faultInTypesForFieldsAndMethods(SourceTypeBinding.java:1113)
	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.faultInTypes(CompilationUnitScope.java:560)
	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:898)
	at org.eclipse.jdt.internal.compiler.ProcessTaskManager.run(ProcessTaskManager.java:145)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.core.resources 4 75 2022-11-02 21:48:28.595
!MESSAGE Errors occurred during the build.
!SUBENTRY 1 org.eclipse.jdt.core 4 75 2022-11-02 21:48:28.595
!MESSAGE Errors running builder 'Java Builder' on project 'ChatServer'.
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.internal.compiler.env.IModule.isAutomatic()" because "module" is null
	at org.eclipse.jdt.internal.compiler.lookup.BinaryModuleBinding.create(BinaryModuleBinding.java:99)
	at org.eclipse.jdt.internal.compiler.impl.ITypeRequestor.accept(ITypeRequestor.java:65)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getModuleFromAnswer(LookupEnvironment.java:437)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForTypeFromModules(LookupEnvironment.java:374)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:236)
	at org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve(UnresolvedReferenceBinding.java:114)
	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveType(BinaryTypeBinding.java:249)
	at org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getType(PackageBinding.java:205)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findType(Scope.java:2027)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java:3502)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:3189)
	at org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference.getTypeBinding(ArrayTypeReference.java:115)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.internalResolveType(TypeReference.java:522)
	at org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference.internalResolveType(ArrayTypeReference.java:202)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:625)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:621)
	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.resolveTypesWithSuspendedTempErrorHandlingPolicy(SourceTypeBinding.java:2803)
	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.resolveTypesFor(SourceTypeBinding.java:2705)
	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.methods(SourceTypeBinding.java:2276)
	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.internalFaultInTypeForFieldsAndMethods(SourceTypeBinding.java:1518)
	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.faultInTypesForFieldsAndMethods(SourceTypeBinding.java:1113)
	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.faultInTypes(CompilationUnitScope.java:560)
	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:898)
	at org.eclipse.jdt.internal.compiler.ProcessTaskManager.run(ProcessTaskManager.java:145)
	at java.base/java.lang.Thread.run(Thread.java:833)
!SESSION 2022-11-03 08:48:31.519 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-11-03 08:48:55.737
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-03 08:48:55.737
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-03 08:48:55.737
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-11-03 08:49:00.840
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\BIT'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.core.resources 4 2 2022-11-03 10:11:15.093
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.core.resources".
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.internal.compiler.env.IModule.isAutomatic()" because "module" is null
	at org.eclipse.jdt.internal.compiler.lookup.BinaryModuleBinding.create(BinaryModuleBinding.java:99)
	at org.eclipse.jdt.internal.compiler.impl.ITypeRequestor.accept(ITypeRequestor.java:65)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getModuleFromAnswer(LookupEnvironment.java:437)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForTypeFromModules(LookupEnvironment.java:374)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:236)
	at org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve(UnresolvedReferenceBinding.java:114)
	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveType(BinaryTypeBinding.java:249)
	at org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getType(PackageBinding.java:205)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findType(Scope.java:2027)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java:3502)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:3189)
	at org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference.getTypeBinding(ArrayTypeReference.java:115)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.internalResolveType(TypeReference.java:522)
	at org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference.internalResolveType(ArrayTypeReference.java:202)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:625)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:621)
	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.resolveTypesWithSuspendedTempErrorHandlingPolicy(SourceTypeBinding.java:2803)
	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.resolveTypesFor(SourceTypeBinding.java:2705)
	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.methods(SourceTypeBinding.java:2276)
	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.internalFaultInTypeForFieldsAndMethods(SourceTypeBinding.java:1518)
	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.faultInTypesForFieldsAndMethods(SourceTypeBinding.java:1113)
	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.faultInTypes(CompilationUnitScope.java:560)
	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:898)
	at org.eclipse.jdt.internal.compiler.ProcessTaskManager.run(ProcessTaskManager.java:145)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.core.resources 4 75 2022-11-03 10:11:15.101
!MESSAGE Errors occurred during the build.
!SUBENTRY 1 org.eclipse.jdt.core 4 75 2022-11-03 10:11:15.102
!MESSAGE Errors running builder 'Java Builder' on project 'ChatServer'.
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.internal.compiler.env.IModule.isAutomatic()" because "module" is null
	at org.eclipse.jdt.internal.compiler.lookup.BinaryModuleBinding.create(BinaryModuleBinding.java:99)
	at org.eclipse.jdt.internal.compiler.impl.ITypeRequestor.accept(ITypeRequestor.java:65)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getModuleFromAnswer(LookupEnvironment.java:437)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForTypeFromModules(LookupEnvironment.java:374)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:236)
	at org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve(UnresolvedReferenceBinding.java:114)
	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveType(BinaryTypeBinding.java:249)
	at org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getType(PackageBinding.java:205)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findType(Scope.java:2027)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java:3502)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:3189)
	at org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference.getTypeBinding(ArrayTypeReference.java:115)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.internalResolveType(TypeReference.java:522)
	at org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference.internalResolveType(ArrayTypeReference.java:202)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:625)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:621)
	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.resolveTypesWithSuspendedTempErrorHandlingPolicy(SourceTypeBinding.java:2803)
	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.resolveTypesFor(SourceTypeBinding.java:2705)
	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.methods(SourceTypeBinding.java:2276)
	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.internalFaultInTypeForFieldsAndMethods(SourceTypeBinding.java:1518)
	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.faultInTypesForFieldsAndMethods(SourceTypeBinding.java:1113)
	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.faultInTypes(CompilationUnitScope.java:560)
	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:898)
	at org.eclipse.jdt.internal.compiler.ProcessTaskManager.run(ProcessTaskManager.java:145)
	at java.base/java.lang.Thread.run(Thread.java:833)
!SESSION 2022-11-04 09:09:55.256 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-11-04 09:10:25.044
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-04 09:10:25.044
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-04 09:10:25.044
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-11-04 09:10:30.649
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\BIT'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-11-04 10:15:19.767 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-11-04 10:15:24.411
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-04 10:15:24.411
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-04 10:15:24.411
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-11-04 10:15:27.708
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\BIT'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.core.resources 2 2 2022-11-04 15:30:50.052
!MESSAGE Save operation warnings.
!SUBENTRY 1 org.eclipse.core.resources 2 234 2022-11-04 15:30:50.052
!MESSAGE The project description file (.project) for 'Practice' was missing.  This file contains important information about the project.  A new project description file has been created, but some information about the project may have been lost.
!SESSION 2022-11-04 20:57:37.872 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-11-04 20:58:06.663
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-04 20:58:06.663
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-04 20:58:06.663
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-11-04 20:58:11.839
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\BIT'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-11-08 20:08:15.387 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-11-08 20:08:42.970
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-08 20:08:42.970
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-08 20:08:42.970
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-11-08 20:08:47.934
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\BIT'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.ui 4 10001 2022-11-08 20:24:45.255
!MESSAGE Internal Error
!STACK 1
Java Model Exception: Core Exception [code 275] A resource exists with a different case: '/JUnit/src/com/calculator'.
	at org.eclipse.jdt.internal.core.JavaModelOperation.createFolder(JavaModelOperation.java:302)
	at org.eclipse.jdt.internal.core.CreatePackageFragmentOperation.executeOperation(CreatePackageFragmentOperation.java:93)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2380)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2405)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:811)
	at org.eclipse.jdt.internal.core.PackageFragmentRoot.createPackageFragment(PackageFragmentRoot.java:321)
	at org.eclipse.jdt.ui.wizards.NewPackageWizardPage.createPackage(NewPackageWizardPage.java:530)
	at org.eclipse.jdt.internal.ui.wizards.NewPackageCreationWizard.finishPage(NewPackageCreationWizard.java:66)
	at org.eclipse.jdt.internal.ui.wizards.NewElementWizard.lambda$1(NewElementWizard.java:118)
	at org.eclipse.jdt.internal.core.BatchOperation.executeOperation(BatchOperation.java:41)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2380)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2405)
	at org.eclipse.jdt.core.JavaCore.run(JavaCore.java:5929)
	at org.eclipse.jdt.internal.ui.actions.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:108)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)
Caused by: java.lang.Exception: A resource exists with a different case: '/JUnit/src/com/calculator'.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.resources.Resource.checkDoesNotExist(Resource.java:318)
	at org.eclipse.core.internal.resources.Resource.checkDoesNotExist(Resource.java:296)
	at org.eclipse.core.internal.resources.Folder.assertCreateRequirements(Folder.java:33)
	at org.eclipse.core.internal.resources.Folder.create(Folder.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.createFolder(JavaModelOperation.java:296)
	... 16 more
Caused by: org.eclipse.core.internal.resources.ResourceException(/JUnit/src/com/calculator)[275]: java.lang.Exception: A resource exists with a different case: '/JUnit/src/com/calculator'.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.resources.Resource.checkDoesNotExist(Resource.java:318)
	at org.eclipse.core.internal.resources.Resource.checkDoesNotExist(Resource.java:296)
	at org.eclipse.core.internal.resources.Folder.assertCreateRequirements(Folder.java:33)
	at org.eclipse.core.internal.resources.Folder.create(Folder.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.createFolder(JavaModelOperation.java:296)
	at org.eclipse.jdt.internal.core.CreatePackageFragmentOperation.executeOperation(CreatePackageFragmentOperation.java:93)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2380)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2405)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:811)
	at org.eclipse.jdt.internal.core.PackageFragmentRoot.createPackageFragment(PackageFragmentRoot.java:321)
	at org.eclipse.jdt.ui.wizards.NewPackageWizardPage.createPackage(NewPackageWizardPage.java:530)
	at org.eclipse.jdt.internal.ui.wizards.NewPackageCreationWizard.finishPage(NewPackageCreationWizard.java:66)
	at org.eclipse.jdt.internal.ui.wizards.NewElementWizard.lambda$1(NewElementWizard.java:118)
	at org.eclipse.jdt.internal.core.BatchOperation.executeOperation(BatchOperation.java:41)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2380)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2405)
	at org.eclipse.jdt.core.JavaCore.run(JavaCore.java:5929)
	at org.eclipse.jdt.internal.ui.actions.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:108)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)
!SUBENTRY 1 org.eclipse.core.resources 4 275 2022-11-08 20:24:45.256
!MESSAGE A resource exists with a different case: '/JUnit/src/com/calculator'.
!STACK 0
java.lang.Exception: A resource exists with a different case: '/JUnit/src/com/calculator'.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.resources.Resource.checkDoesNotExist(Resource.java:318)
	at org.eclipse.core.internal.resources.Resource.checkDoesNotExist(Resource.java:296)
	at org.eclipse.core.internal.resources.Folder.assertCreateRequirements(Folder.java:33)
	at org.eclipse.core.internal.resources.Folder.create(Folder.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.createFolder(JavaModelOperation.java:296)
	at org.eclipse.jdt.internal.core.CreatePackageFragmentOperation.executeOperation(CreatePackageFragmentOperation.java:93)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2380)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2405)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:811)
	at org.eclipse.jdt.internal.core.PackageFragmentRoot.createPackageFragment(PackageFragmentRoot.java:321)
	at org.eclipse.jdt.ui.wizards.NewPackageWizardPage.createPackage(NewPackageWizardPage.java:530)
	at org.eclipse.jdt.internal.ui.wizards.NewPackageCreationWizard.finishPage(NewPackageCreationWizard.java:66)
	at org.eclipse.jdt.internal.ui.wizards.NewElementWizard.lambda$1(NewElementWizard.java:118)
	at org.eclipse.jdt.internal.core.BatchOperation.executeOperation(BatchOperation.java:41)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2380)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2405)
	at org.eclipse.jdt.core.JavaCore.run(JavaCore.java:5929)
	at org.eclipse.jdt.internal.ui.actions.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:108)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)

!ENTRY org.eclipse.jdt.junit 4 0 2022-11-08 21:24:00.752
!MESSAGE No tests found with test runner 'JUnit 5'.

!ENTRY org.eclipse.jdt.junit 4 0 2022-11-08 21:26:00.644
!MESSAGE No tests found with test runner 'JUnit 5'.

!ENTRY org.eclipse.jface 4 2 2022-11-08 21:26:22.975
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jface".
!STACK 0
java.lang.ClassCastException: class org.eclipse.core.internal.resources.File cannot be cast to class org.eclipse.core.resources.IProject (org.eclipse.core.internal.resources.File and org.eclipse.core.resources.IProject are in unnamed module of loader org.eclipse.osgi.internal.loader.EquinoxClassLoader @46d0f89c)
	at org.eclipse.jdt.internal.ui.preferences.PropertyAndPreferencePage.setElement(PropertyAndPreferencePage.java:327)
	at org.eclipse.ui.internal.dialogs.RegistryPageContributor.createPage(RegistryPageContributor.java:145)
	at org.eclipse.ui.internal.dialogs.PropertyPageNode.createPage(PropertyPageNode.java:60)
	at org.eclipse.jface.preference.PreferenceDialog.createPage(PreferenceDialog.java:1280)
	at org.eclipse.ui.internal.dialogs.FilteredPreferenceDialog.createPage(FilteredPreferenceDialog.java:338)
	at org.eclipse.jface.preference.PreferenceDialog.showPage(PreferenceDialog.java:1166)
	at org.eclipse.ui.internal.dialogs.FilteredPreferenceDialog.showPage(FilteredPreferenceDialog.java:630)
	at org.eclipse.jface.preference.PreferenceDialog$5.lambda$0(PreferenceDialog.java:660)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jface.preference.PreferenceDialog$5.selectionChanged(PreferenceDialog.java:657)
	at org.eclipse.jface.viewers.StructuredViewer$3.run(StructuredViewer.java:821)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:174)
	at org.eclipse.jface.viewers.StructuredViewer.firePostSelectionChanged(StructuredViewer.java:818)
	at org.eclipse.jface.viewers.StructuredViewer.handlePostSelect(StructuredViewer.java:1191)
	at org.eclipse.swt.events.SelectionListener$1.widgetSelected(SelectionListener.java:84)
	at org.eclipse.jface.util.OpenStrategy.firePostSelectionEvent(OpenStrategy.java:284)
	at org.eclipse.jface.util.OpenStrategy$1.lambda$1(OpenStrategy.java:438)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:132)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4043)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3648)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.ui.dialogs.PropertyDialogAction.run(PropertyDialogAction.java:155)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.junit 4 0 2022-11-08 21:29:21.819
!MESSAGE No tests found with test runner 'JUnit 5'.

!ENTRY org.eclipse.jdt.junit 4 0 2022-11-08 21:29:53.291
!MESSAGE No tests found with test runner 'JUnit 5'.
!SESSION 2022-11-09 11:50:50.917 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-11-09 11:51:17.035
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-09 11:51:17.035
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-09 11:51:17.035
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-11-09 11:51:22.383
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\BIT'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.ui 4 10001 2022-11-09 12:28:48.682
!MESSAGE Internal Error
!STACK 1
Java Model Exception: Error in Java Model (code 969): 006814-master does not exist
	at org.eclipse.jdt.internal.core.JavaElement.newNotPresentException(JavaElement.java:574)
	at org.eclipse.jdt.internal.core.JavaModelManager.getPerProjectInfoCheckExistence(JavaModelManager.java:2503)
	at org.eclipse.jdt.internal.core.JavaProject.getPerProjectInfo(JavaProject.java:2444)
	at org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath(JavaProject.java:2517)
	at org.eclipse.jdt.internal.core.PackageFragmentRoot.getResolvedClasspathEntry(PackageFragmentRoot.java:624)
	at org.eclipse.jdt.ui.wizards.NewContainerWizardPage.initContainerPage(NewContainerWizardPage.java:161)
	at org.eclipse.jdt.junit.wizards.NewTestCaseWizardPageOne.init(NewTestCaseWizardPageOne.java:247)
	at org.eclipse.jdt.internal.junit.wizards.NewTestCaseCreationWizard.addPages(NewTestCaseCreationWizard.java:94)
	at org.eclipse.jface.wizard.WizardDialog.createContents(WizardDialog.java:633)
	at org.eclipse.jface.window.Window.create(Window.java:431)
	at org.eclipse.jface.dialogs.Dialog.create(Dialog.java:1094)
	at org.eclipse.ui.internal.actions.NewWizardShortcutAction.run(NewWizardShortcutAction.java:119)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.jdt.core 4 969 2022-11-09 12:28:48.683
!MESSAGE 006814-master does not exist

!ENTRY org.eclipse.jdt.junit 4 4 2022-11-09 12:28:48.697
!MESSAGE Error
!STACK 1
Java Model Exception: Error in Java Model (code 969): 006814-master does not exist
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.SourceType.newSupertypeHierarchy(SourceType.java:858)
	at org.eclipse.jdt.internal.core.SourceType.newSupertypeHierarchy(SourceType.java:809)
	at org.eclipse.jdt.internal.junit.util.CoreTestSearchEngine.isTestImplementor(CoreTestSearchEngine.java:167)
	at org.eclipse.jdt.junit.wizards.NewTestCaseWizardPageOne.init(NewTestCaseWizardPageOne.java:276)
	at org.eclipse.jdt.internal.junit.wizards.NewTestCaseCreationWizard.addPages(NewTestCaseCreationWizard.java:94)
	at org.eclipse.jface.wizard.WizardDialog.createContents(WizardDialog.java:633)
	at org.eclipse.jface.window.Window.create(Window.java:431)
	at org.eclipse.jface.dialogs.Dialog.create(Dialog.java:1094)
	at org.eclipse.ui.internal.actions.NewWizardShortcutAction.run(NewWizardShortcutAction.java:119)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.jdt.core 4 969 2022-11-09 12:28:48.697
!MESSAGE 006814-master does not exist

!ENTRY org.eclipse.jdt.ui 4 10001 2022-11-09 12:32:16.019
!MESSAGE Internal Error
!STACK 1
Java Model Exception: Error in Java Model (code 969): 006814-master does not exist
	at org.eclipse.jdt.internal.core.JavaElement.newNotPresentException(JavaElement.java:574)
	at org.eclipse.jdt.internal.core.JavaModelManager.getPerProjectInfoCheckExistence(JavaModelManager.java:2503)
	at org.eclipse.jdt.internal.core.JavaProject.getPerProjectInfo(JavaProject.java:2444)
	at org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath(JavaProject.java:2517)
	at org.eclipse.jdt.internal.core.PackageFragmentRoot.getResolvedClasspathEntry(PackageFragmentRoot.java:624)
	at org.eclipse.jdt.ui.wizards.NewContainerWizardPage.initContainerPage(NewContainerWizardPage.java:161)
	at org.eclipse.jdt.junit.wizards.NewTestCaseWizardPageOne.init(NewTestCaseWizardPageOne.java:247)
	at org.eclipse.jdt.internal.junit.wizards.NewTestCaseCreationWizard.addPages(NewTestCaseCreationWizard.java:94)
	at org.eclipse.jface.wizard.WizardDialog.createContents(WizardDialog.java:633)
	at org.eclipse.jface.window.Window.create(Window.java:431)
	at org.eclipse.jface.dialogs.Dialog.create(Dialog.java:1094)
	at org.eclipse.ui.internal.actions.NewWizardShortcutAction.run(NewWizardShortcutAction.java:119)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.jdt.core 4 969 2022-11-09 12:32:16.019
!MESSAGE 006814-master does not exist

!ENTRY org.eclipse.jdt.junit 4 4 2022-11-09 12:32:16.022
!MESSAGE Error
!STACK 1
Java Model Exception: Error in Java Model (code 969): 006814-master does not exist
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.SourceType.newSupertypeHierarchy(SourceType.java:858)
	at org.eclipse.jdt.internal.core.SourceType.newSupertypeHierarchy(SourceType.java:809)
	at org.eclipse.jdt.internal.junit.util.CoreTestSearchEngine.isTestImplementor(CoreTestSearchEngine.java:167)
	at org.eclipse.jdt.junit.wizards.NewTestCaseWizardPageOne.init(NewTestCaseWizardPageOne.java:276)
	at org.eclipse.jdt.internal.junit.wizards.NewTestCaseCreationWizard.addPages(NewTestCaseCreationWizard.java:94)
	at org.eclipse.jface.wizard.WizardDialog.createContents(WizardDialog.java:633)
	at org.eclipse.jface.window.Window.create(Window.java:431)
	at org.eclipse.jface.dialogs.Dialog.create(Dialog.java:1094)
	at org.eclipse.ui.internal.actions.NewWizardShortcutAction.run(NewWizardShortcutAction.java:119)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.jdt.core 4 969 2022-11-09 12:32:16.022
!MESSAGE 006814-master does not exist

!ENTRY org.eclipse.jdt.ui 4 10001 2022-11-09 12:38:45.668
!MESSAGE Internal Error
!STACK 1
Java Model Exception: Error in Java Model (code 969): 006814-master does not exist
	at org.eclipse.jdt.internal.core.JavaElement.newNotPresentException(JavaElement.java:574)
	at org.eclipse.jdt.internal.core.JavaModelManager.getPerProjectInfoCheckExistence(JavaModelManager.java:2503)
	at org.eclipse.jdt.internal.core.JavaProject.getPerProjectInfo(JavaProject.java:2444)
	at org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath(JavaProject.java:2517)
	at org.eclipse.jdt.internal.core.PackageFragmentRoot.getResolvedClasspathEntry(PackageFragmentRoot.java:624)
	at org.eclipse.jdt.ui.wizards.NewContainerWizardPage.initContainerPage(NewContainerWizardPage.java:161)
	at org.eclipse.jdt.junit.wizards.NewTestCaseWizardPageOne.init(NewTestCaseWizardPageOne.java:247)
	at org.eclipse.jdt.internal.junit.wizards.NewTestCaseCreationWizard.addPages(NewTestCaseCreationWizard.java:94)
	at org.eclipse.jface.wizard.WizardDialog.createContents(WizardDialog.java:633)
	at org.eclipse.jface.window.Window.create(Window.java:431)
	at org.eclipse.jface.dialogs.Dialog.create(Dialog.java:1094)
	at org.eclipse.ui.internal.actions.NewWizardShortcutAction.run(NewWizardShortcutAction.java:119)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.jdt.core 4 969 2022-11-09 12:38:45.668
!MESSAGE 006814-master does not exist

!ENTRY org.eclipse.jdt.junit 4 4 2022-11-09 12:38:45.670
!MESSAGE Error
!STACK 1
Java Model Exception: Error in Java Model (code 969): 006814-master does not exist
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.SourceType.newSupertypeHierarchy(SourceType.java:858)
	at org.eclipse.jdt.internal.core.SourceType.newSupertypeHierarchy(SourceType.java:809)
	at org.eclipse.jdt.internal.junit.util.CoreTestSearchEngine.isTestImplementor(CoreTestSearchEngine.java:167)
	at org.eclipse.jdt.junit.wizards.NewTestCaseWizardPageOne.init(NewTestCaseWizardPageOne.java:276)
	at org.eclipse.jdt.internal.junit.wizards.NewTestCaseCreationWizard.addPages(NewTestCaseCreationWizard.java:94)
	at org.eclipse.jface.wizard.WizardDialog.createContents(WizardDialog.java:633)
	at org.eclipse.jface.window.Window.create(Window.java:431)
	at org.eclipse.jface.dialogs.Dialog.create(Dialog.java:1094)
	at org.eclipse.ui.internal.actions.NewWizardShortcutAction.run(NewWizardShortcutAction.java:119)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.jdt.core 4 969 2022-11-09 12:38:45.670
!MESSAGE 006814-master does not exist
!SESSION 2022-11-09 12:39:55.425 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-11-09 12:40:00.367
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-09 12:40:00.367
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-09 12:40:00.367
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-11-09 12:40:04.594
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\BIT'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-11-10 14:14:18.388 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2022-11-10 14:14:44.870
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-10 14:14:44.870
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-10 14:14:44.870
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-11-10 14:14:48.539
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\BIT'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.equinox.p2.core 4 0 2022-11-10 14:27:01.389
!MESSAGE Provisioning exception
!STACK 1
org.eclipse.equinox.p2.core.ProvisionException: Artifact not found: http://downloads.sourceforge.net/project/sapnweclipse/updates/features/com.sap.netweaver.porta.ide.eclipse.feature_0.6.0.200912021058.jar.
	at org.eclipse.equinox.internal.p2.updatesite.UpdateSite.parseFeature(UpdateSite.java:303)
	at org.eclipse.equinox.internal.p2.updatesite.UpdateSite.loadFeaturesFromSite(UpdateSite.java:601)
	at org.eclipse.equinox.internal.p2.updatesite.UpdateSite.loadFeatures(UpdateSite.java:496)
	at org.eclipse.equinox.internal.p2.updatesite.RemoteFeaturesAction.perform(RemoteFeaturesAction.java:45)
	at org.eclipse.equinox.internal.p2.updatesite.RemoteUpdateSiteAction.perform(RemoteUpdateSiteAction.java:54)
	at org.eclipse.equinox.p2.publisher.Publisher$ArtifactProcess.run(Publisher.java:288)
	at org.eclipse.equinox.p2.publisher.Publisher.publish(Publisher.java:318)
	at org.eclipse.equinox.internal.p2.updatesite.metadata.UpdateSiteMetadataRepositoryFactory.generateMetadata(UpdateSiteMetadataRepositoryFactory.java:129)
	at org.eclipse.equinox.internal.p2.updatesite.metadata.UpdateSiteMetadataRepositoryFactory.initializeRepository(UpdateSiteMetadataRepositoryFactory.java:114)
	at org.eclipse.equinox.internal.p2.updatesite.metadata.UpdateSiteMetadataRepositoryFactory.load(UpdateSiteMetadataRepositoryFactory.java:62)
	at org.eclipse.wst.server.discovery.internal.model.ExtensionUpdateSite.getExtensions(ExtensionUpdateSite.java:111)
	at org.eclipse.wst.server.discovery.internal.ExtensionUtility$1.run(ExtensionUtility.java:509)
Caused by: java.io.FileNotFoundException: http://downloads.sourceforge.net/project/sapnweclipse/updates/features/com.sap.netweaver.porta.ide.eclipse.feature_0.6.0.200912021058.jar
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryStatusHelper.checkFileNotFound(RepositoryStatusHelper.java:298)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.checkException(FileReader.java:511)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.sendRetrieveRequest(FileReader.java:465)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.readInto(FileReader.java:386)
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport.download(RepositoryTransport.java:107)
	at org.eclipse.oomph.p2.internal.core.CachingTransport.download(CachingTransport.java:136)
	at org.eclipse.equinox.internal.p2.updatesite.UpdateSite.parseFeature(UpdateSite.java:287)
	... 11 more
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1200 2022-11-10 14:27:01.390
!MESSAGE Artifact not found: http://downloads.sourceforge.net/project/sapnweclipse/updates/features/com.sap.netweaver.porta.ide.eclipse.feature_0.6.0.200912021058.jar.
!STACK 0
java.io.FileNotFoundException: http://downloads.sourceforge.net/project/sapnweclipse/updates/features/com.sap.netweaver.porta.ide.eclipse.feature_0.6.0.200912021058.jar
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryStatusHelper.checkFileNotFound(RepositoryStatusHelper.java:298)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.checkException(FileReader.java:511)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.sendRetrieveRequest(FileReader.java:465)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.readInto(FileReader.java:386)
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport.download(RepositoryTransport.java:107)
	at org.eclipse.oomph.p2.internal.core.CachingTransport.download(CachingTransport.java:136)
	at org.eclipse.equinox.internal.p2.updatesite.UpdateSite.parseFeature(UpdateSite.java:287)
	at org.eclipse.equinox.internal.p2.updatesite.UpdateSite.loadFeaturesFromSite(UpdateSite.java:601)
	at org.eclipse.equinox.internal.p2.updatesite.UpdateSite.loadFeatures(UpdateSite.java:496)
	at org.eclipse.equinox.internal.p2.updatesite.RemoteFeaturesAction.perform(RemoteFeaturesAction.java:45)
	at org.eclipse.equinox.internal.p2.updatesite.RemoteUpdateSiteAction.perform(RemoteUpdateSiteAction.java:54)
	at org.eclipse.equinox.p2.publisher.Publisher$ArtifactProcess.run(Publisher.java:288)
	at org.eclipse.equinox.p2.publisher.Publisher.publish(Publisher.java:318)
	at org.eclipse.equinox.internal.p2.updatesite.metadata.UpdateSiteMetadataRepositoryFactory.generateMetadata(UpdateSiteMetadataRepositoryFactory.java:129)
	at org.eclipse.equinox.internal.p2.updatesite.metadata.UpdateSiteMetadataRepositoryFactory.initializeRepository(UpdateSiteMetadataRepositoryFactory.java:114)
	at org.eclipse.equinox.internal.p2.updatesite.metadata.UpdateSiteMetadataRepositoryFactory.load(UpdateSiteMetadataRepositoryFactory.java:62)
	at org.eclipse.wst.server.discovery.internal.model.ExtensionUpdateSite.getExtensions(ExtensionUpdateSite.java:111)
	at org.eclipse.wst.server.discovery.internal.ExtensionUtility$1.run(ExtensionUtility.java:509)

!ENTRY org.eclipse.equinox.p2.updatesite 4 0 2022-11-10 14:27:01.391
!MESSAGE Error reading feature http://downloads.sourceforge.net/project/sapnweclipse/updates/features/com.sap.netweaver.porta.ide.eclipse.feature_0.6.0.200912021058.jar.

!ENTRY org.eclipse.equinox.p2.core 4 0 2022-11-10 14:27:02.045
!MESSAGE Provisioning exception
!STACK 1
org.eclipse.equinox.p2.core.ProvisionException: Artifact not found: http://downloads.sourceforge.net/project/sapnweclipse/updates/features/com.sap.netweaver.porta.ide.eclipse.feature_0.6.1.201004082044.jar.
	at org.eclipse.equinox.internal.p2.updatesite.UpdateSite.parseFeature(UpdateSite.java:303)
	at org.eclipse.equinox.internal.p2.updatesite.UpdateSite.loadFeaturesFromSite(UpdateSite.java:601)
	at org.eclipse.equinox.internal.p2.updatesite.UpdateSite.loadFeatures(UpdateSite.java:496)
	at org.eclipse.equinox.internal.p2.updatesite.RemoteFeaturesAction.perform(RemoteFeaturesAction.java:45)
	at org.eclipse.equinox.internal.p2.updatesite.RemoteUpdateSiteAction.perform(RemoteUpdateSiteAction.java:54)
	at org.eclipse.equinox.p2.publisher.Publisher$ArtifactProcess.run(Publisher.java:288)
	at org.eclipse.equinox.p2.publisher.Publisher.publish(Publisher.java:318)
	at org.eclipse.equinox.internal.p2.updatesite.metadata.UpdateSiteMetadataRepositoryFactory.generateMetadata(UpdateSiteMetadataRepositoryFactory.java:129)
	at org.eclipse.equinox.internal.p2.updatesite.metadata.UpdateSiteMetadataRepositoryFactory.initializeRepository(UpdateSiteMetadataRepositoryFactory.java:114)
	at org.eclipse.equinox.internal.p2.updatesite.metadata.UpdateSiteMetadataRepositoryFactory.load(UpdateSiteMetadataRepositoryFactory.java:62)
	at org.eclipse.wst.server.discovery.internal.model.ExtensionUpdateSite.getExtensions(ExtensionUpdateSite.java:111)
	at org.eclipse.wst.server.discovery.internal.ExtensionUtility$1.run(ExtensionUtility.java:509)
Caused by: java.io.FileNotFoundException: http://downloads.sourceforge.net/project/sapnweclipse/updates/features/com.sap.netweaver.porta.ide.eclipse.feature_0.6.1.201004082044.jar
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryStatusHelper.checkFileNotFound(RepositoryStatusHelper.java:298)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.checkException(FileReader.java:511)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.sendRetrieveRequest(FileReader.java:465)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.readInto(FileReader.java:386)
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport.download(RepositoryTransport.java:107)
	at org.eclipse.oomph.p2.internal.core.CachingTransport.download(CachingTransport.java:136)
	at org.eclipse.equinox.internal.p2.updatesite.UpdateSite.parseFeature(UpdateSite.java:287)
	... 11 more
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1200 2022-11-10 14:27:02.046
!MESSAGE Artifact not found: http://downloads.sourceforge.net/project/sapnweclipse/updates/features/com.sap.netweaver.porta.ide.eclipse.feature_0.6.1.201004082044.jar.
!STACK 0
java.io.FileNotFoundException: http://downloads.sourceforge.net/project/sapnweclipse/updates/features/com.sap.netweaver.porta.ide.eclipse.feature_0.6.1.201004082044.jar
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryStatusHelper.checkFileNotFound(RepositoryStatusHelper.java:298)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.checkException(FileReader.java:511)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.sendRetrieveRequest(FileReader.java:465)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.readInto(FileReader.java:386)
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport.download(RepositoryTransport.java:107)
	at org.eclipse.oomph.p2.internal.core.CachingTransport.download(CachingTransport.java:136)
	at org.eclipse.equinox.internal.p2.updatesite.UpdateSite.parseFeature(UpdateSite.java:287)
	at org.eclipse.equinox.internal.p2.updatesite.UpdateSite.loadFeaturesFromSite(UpdateSite.java:601)
	at org.eclipse.equinox.internal.p2.updatesite.UpdateSite.loadFeatures(UpdateSite.java:496)
	at org.eclipse.equinox.internal.p2.updatesite.RemoteFeaturesAction.perform(RemoteFeaturesAction.java:45)
	at org.eclipse.equinox.internal.p2.updatesite.RemoteUpdateSiteAction.perform(RemoteUpdateSiteAction.java:54)
	at org.eclipse.equinox.p2.publisher.Publisher$ArtifactProcess.run(Publisher.java:288)
	at org.eclipse.equinox.p2.publisher.Publisher.publish(Publisher.java:318)
	at org.eclipse.equinox.internal.p2.updatesite.metadata.UpdateSiteMetadataRepositoryFactory.generateMetadata(UpdateSiteMetadataRepositoryFactory.java:129)
	at org.eclipse.equinox.internal.p2.updatesite.metadata.UpdateSiteMetadataRepositoryFactory.initializeRepository(UpdateSiteMetadataRepositoryFactory.java:114)
	at org.eclipse.equinox.internal.p2.updatesite.metadata.UpdateSiteMetadataRepositoryFactory.load(UpdateSiteMetadataRepositoryFactory.java:62)
	at org.eclipse.wst.server.discovery.internal.model.ExtensionUpdateSite.getExtensions(ExtensionUpdateSite.java:111)
	at org.eclipse.wst.server.discovery.internal.ExtensionUtility$1.run(ExtensionUtility.java:509)

!ENTRY org.eclipse.equinox.p2.updatesite 4 0 2022-11-10 14:27:02.047
!MESSAGE Error reading feature http://downloads.sourceforge.net/project/sapnweclipse/updates/features/com.sap.netweaver.porta.ide.eclipse.feature_0.6.1.201004082044.jar.

!ENTRY org.eclipse.equinox.p2.core 4 0 2022-11-10 14:27:03.877
!MESSAGE Provisioning exception
!STACK 1
org.eclipse.equinox.p2.core.ProvisionException: Artifact not found: http://downloads.sourceforge.net/project/sapnweclipse/updates/features/com.sap.netweaver.porta.ide.eclipse.feature_0.7.1.201005191610.jar.
	at org.eclipse.equinox.internal.p2.updatesite.UpdateSite.parseFeature(UpdateSite.java:303)
	at org.eclipse.equinox.internal.p2.updatesite.UpdateSite.loadFeaturesFromSite(UpdateSite.java:601)
	at org.eclipse.equinox.internal.p2.updatesite.UpdateSite.loadFeatures(UpdateSite.java:496)
	at org.eclipse.equinox.internal.p2.updatesite.RemoteFeaturesAction.perform(RemoteFeaturesAction.java:45)
	at org.eclipse.equinox.internal.p2.updatesite.RemoteUpdateSiteAction.perform(RemoteUpdateSiteAction.java:54)
	at org.eclipse.equinox.p2.publisher.Publisher$ArtifactProcess.run(Publisher.java:288)
	at org.eclipse.equinox.p2.publisher.Publisher.publish(Publisher.java:318)
	at org.eclipse.equinox.internal.p2.updatesite.metadata.UpdateSiteMetadataRepositoryFactory.generateMetadata(UpdateSiteMetadataRepositoryFactory.java:129)
	at org.eclipse.equinox.internal.p2.updatesite.metadata.UpdateSiteMetadataRepositoryFactory.initializeRepository(UpdateSiteMetadataRepositoryFactory.java:114)
	at org.eclipse.equinox.internal.p2.updatesite.metadata.UpdateSiteMetadataRepositoryFactory.load(UpdateSiteMetadataRepositoryFactory.java:62)
	at org.eclipse.wst.server.discovery.internal.model.ExtensionUpdateSite.getExtensions(ExtensionUpdateSite.java:111)
	at org.eclipse.wst.server.discovery.internal.ExtensionUtility$1.run(ExtensionUtility.java:509)
Caused by: java.io.FileNotFoundException: http://downloads.sourceforge.net/project/sapnweclipse/updates/features/com.sap.netweaver.porta.ide.eclipse.feature_0.7.1.201005191610.jar
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryStatusHelper.checkFileNotFound(RepositoryStatusHelper.java:298)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.checkException(FileReader.java:511)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.sendRetrieveRequest(FileReader.java:465)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.readInto(FileReader.java:386)
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport.download(RepositoryTransport.java:107)
	at org.eclipse.oomph.p2.internal.core.CachingTransport.download(CachingTransport.java:136)
	at org.eclipse.equinox.internal.p2.updatesite.UpdateSite.parseFeature(UpdateSite.java:287)
	... 11 more
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1200 2022-11-10 14:27:03.877
!MESSAGE Artifact not found: http://downloads.sourceforge.net/project/sapnweclipse/updates/features/com.sap.netweaver.porta.ide.eclipse.feature_0.7.1.201005191610.jar.
!STACK 0
java.io.FileNotFoundException: http://downloads.sourceforge.net/project/sapnweclipse/updates/features/com.sap.netweaver.porta.ide.eclipse.feature_0.7.1.201005191610.jar
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryStatusHelper.checkFileNotFound(RepositoryStatusHelper.java:298)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.checkException(FileReader.java:511)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.sendRetrieveRequest(FileReader.java:465)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.readInto(FileReader.java:386)
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport.download(RepositoryTransport.java:107)
	at org.eclipse.oomph.p2.internal.core.CachingTransport.download(CachingTransport.java:136)
	at org.eclipse.equinox.internal.p2.updatesite.UpdateSite.parseFeature(UpdateSite.java:287)
	at org.eclipse.equinox.internal.p2.updatesite.UpdateSite.loadFeaturesFromSite(UpdateSite.java:601)
	at org.eclipse.equinox.internal.p2.updatesite.UpdateSite.loadFeatures(UpdateSite.java:496)
	at org.eclipse.equinox.internal.p2.updatesite.RemoteFeaturesAction.perform(RemoteFeaturesAction.java:45)
	at org.eclipse.equinox.internal.p2.updatesite.RemoteUpdateSiteAction.perform(RemoteUpdateSiteAction.java:54)
	at org.eclipse.equinox.p2.publisher.Publisher$ArtifactProcess.run(Publisher.java:288)
	at org.eclipse.equinox.p2.publisher.Publisher.publish(Publisher.java:318)
	at org.eclipse.equinox.internal.p2.updatesite.metadata.UpdateSiteMetadataRepositoryFactory.generateMetadata(UpdateSiteMetadataRepositoryFactory.java:129)
	at org.eclipse.equinox.internal.p2.updatesite.metadata.UpdateSiteMetadataRepositoryFactory.initializeRepository(UpdateSiteMetadataRepositoryFactory.java:114)
	at org.eclipse.equinox.internal.p2.updatesite.metadata.UpdateSiteMetadataRepositoryFactory.load(UpdateSiteMetadataRepositoryFactory.java:62)
	at org.eclipse.wst.server.discovery.internal.model.ExtensionUpdateSite.getExtensions(ExtensionUpdateSite.java:111)
	at org.eclipse.wst.server.discovery.internal.ExtensionUtility$1.run(ExtensionUtility.java:509)

!ENTRY org.eclipse.equinox.p2.updatesite 4 0 2022-11-10 14:27:03.878
!MESSAGE Error reading feature http://downloads.sourceforge.net/project/sapnweclipse/updates/features/com.sap.netweaver.porta.ide.eclipse.feature_0.7.1.201005191610.jar.
